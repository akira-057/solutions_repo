{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \ud83d\udccc Mechanics: Investigating the Range as a Function of the Angle of Projection \ud83c\udff9 Motivation Projectile motion appears simple, yet it encapsulates deep physical principles. By analyzing how the range of a projectile varies with its launch angle, we uncover fascinating relationships governed by linear and quadratic equations. These equations have broad applications, from sports (e.g., the trajectory of a soccer ball) to engineering (e.g., missile launch dynamics). \u2696 1. Theoretical Foundation \ud83d\udcdc Equations of Motion A projectile launched with an initial velocity \\($ v_0 $\\) at an angle \\($ \\theta$ \\) follows a parabolic trajectory under the influence of gravity. We derive its motion using Newton's laws. \ud83d\udd39 Horizontal Motion Since there is no acceleration in the horizontal direction (assuming no air resistance), the velocity remains constant \\[ $ x(t) = v_0 \\cos\\theta \\cdot t $ \\] \ud83d\udd39 Vertical Motion The vertical motion is governed by constant acceleration due to gravity \\($ g \\) : \\[ $ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $ \\] The projectile reaches the ground when \\($ y = 0 $\\) , solving for \\($ t $\\) : \\[ $ t_f = \\frac{2 v_0 \\sin\\theta}{g} $ \\] This is the total time of flight . \ud83d\udccf 2. Analysis of the Range The range \\($ R \\) is the horizontal distance covered by the projectile when it lands: \\[ $ R = x(t_f) = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} $\\] Using the identity \\($ 2\\sin\\theta\\cos\\theta = \\sin 2\\theta $\\) , we get: \\[ R = $\\frac{v_0^2}{g} \\sin 2\\theta $ \\] \ud83d\udccc Key Observations: Maximum Range: The range is maximized when \\($ \\sin 2\\theta = 1 $\\) , i.e., \\($ 2\\theta = 90^\\circ $\\) \u2192 \\($ \\theta = 45^\\circ $\\) . Symmetry: The function \\($ R(\\theta) $\\) is symmetric around \\($ 45^\\circ $\\) , meaning \\($ R(\\theta) = R(90^\\circ - \\theta) $\\) . Effect of Initial Velocity: Since \\($ R \\propto v_0^2 $\\) , doubling \\($ v_0 $\\) quadruples the range. Effect of Gravity: Since \\($ R \\propto \\frac{1}{g} $\\) , projectiles travel farther on planets with lower gravity (e.g., the Moon). \ud83c\udf0e 3. Practical Applications Sports: Soccer: Kicking a ball at \\($ 45^\\circ $\\) for maximum distance. Basketball: Analyzing the optimal shooting angle. Engineering & Ballistics: Missile trajectories and range optimization. Water fountains and fluid mechanics. Astrophysics: Moon landings require adjusting launch angles based on gravity. \ud83d\udcbb 4. Implementation (Python Simulation) \ud83d\udd39 Graph Interpretation The maximum range occurs at \u03b8 = 45\u00b0 The function is symmetric about 45\u00b0 Higher v\u2080 increases range quadratically \ud83d\udd39 Limitations of the Model Assumes no air resistance Assumes flat terrain (ignores hills, obstacles) Ignores wind effects , which can alter trajectories \ud83d\udd39 Enhancements Add air drag to create more realistic simulations Consider launches from elevated platforms (e.g., artillery firing from a hill) Visit My Collab import numpy as np import matplotlib.pyplot as plt # Gravitational acceleration g = 9.81 # Function to plot the trajectory def trajectory(v0, angle_deg): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Graph (a) plt.figure(figsize=(12, 10)) plt.subplot(2, 1, 1) for v0, color in zip([30, 40, 50], ['red', 'purple', 'green']): x, y = trajectory(v0, 45) plt.plot(x, y, color=color, label=f'{v0} m/s') plt.title('(a) Same angle (45\u00b0), different speeds') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(91.8, color='black', linestyle='--') plt.axvline(163, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 70) # Graph (b) plt.subplot(2, 1, 2) v0 = 50 for angle, color in zip([15, 45, 75], ['red', 'purple', 'green']): x, y = trajectory(v0, angle) plt.plot(x, y, color=color, label=f'{angle}\u00b0') plt.title('(b) Same speed (50 m/s), different angles') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(128, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 130) plt.tight_layout() plt.show() \ud83c\udfaf Projectile Motion Analysis \ud83d\udcca Graph (a): Different Initial Speeds, Same Angle (45\u00b0) Launch angle: 45\u00b0 \u2014 this is the optimal angle for achieving maximum range when the initial speed is fixed. Initial speeds: - 30 m/s (\ud83d\udd34 red trajectory) - 40 m/s (\ud83d\udfe3 purple trajectory) - 50 m/s (\ud83d\udfe2 green trajectory) Conclusion: The greater the initial speed (with a fixed angle), the farther the projectile travels. Example ranges (R): - 30 m/s \u2192 R \u2248 91.8 m - 40 m/s \u2192 R \u2248 163 m - 50 m/s \u2192 R \u2248 255 m \ud83d\udccc Range formula: R = (v\u2080\u00b2 * sin(2\u03b8)) / g When \u03b8 = 45\u00b0 , sin(2\u03b8) = sin(90\u00b0) = 1 \u2192 So the range depends only on v\u2080\u00b2 . \ud83d\udcca Graph (b): Same Initial Speed (50 m/s), Different Angles Initial speed: 50 m/s for all three trajectories. Angles: - 15\u00b0 (\ud83d\udd34 red): low trajectory, small height and short range. - 45\u00b0 (\ud83d\udfe3 purple): maximum range. - 75\u00b0 (\ud83d\udfe2 green): high trajectory, but shorter range. Interesting fact: 15\u00b0 and 75\u00b0 give equal range ( R \u2248 128 m ), even though the shapes of the trajectories are very different. \ud83d\udccc Symmetry Law: Angles \u03b8 and 90\u00b0 \u2212 \u03b8 give the same range, because: sin(2\u03b8) = sin(2(90\u00b0 \u2212 \u03b8)) = sin(180\u00b0 \u2212 2\u03b8) = sin(2\u03b8) \ud83e\udde0 Main Takeaways: The best angle for maximum range with a given speed is 45\u00b0 . With the same angle, higher speed means greater range. Angles that add up to 90\u00b0 (like 15\u00b0 and 75\u00b0 ) give the same range, but different heights and flight paths. Visit My Collab import numpy as np import matplotlib.pyplot as plt # Gravitational acceleration g = 9.81 # Function to plot the trajectory def trajectory(v0, angle_deg): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Graph (a) plt.figure(figsize=(12, 10)) plt.subplot(2, 1, 1) for v0, color in zip([30, 40, 50], ['red', 'purple', 'green']): x, y = trajectory(v0, 45) plt.plot(x, y, color=color, label=f'{v0} m/s') plt.title('(a) Same angle (45\u00b0), different speeds') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(91.8, color='black', linestyle='--') plt.axvline(163, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 70) # Graph (b) plt.subplot(2, 1, 2) v0 = 50 for angle, color in zip([15, 45, 75], ['red', 'purple', 'green']): x, y = trajectory(v0, angle) plt.plot(x, y, color=color, label=f'{angle}\u00b0') plt.title('(b) Same speed (50 m/s), different angles') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(128, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 130) plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83d\udccc Mechanics: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion appears simple, yet it encapsulates deep physical principles. By analyzing how the range of a projectile varies with its launch angle, we uncover fascinating relationships governed by linear and quadratic equations. These equations have broad applications, from sports (e.g., the trajectory of a soccer ball) to engineering (e.g., missile launch dynamics).","title":"\ud83c\udff9 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"A projectile launched with an initial velocity \\($ v_0 $\\) at an angle \\($ \\theta$ \\) follows a parabolic trajectory under the influence of gravity. We derive its motion using Newton's laws.","title":"\ud83d\udcdc Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Since there is no acceleration in the horizontal direction (assuming no air resistance), the velocity remains constant \\[ $ x(t) = v_0 \\cos\\theta \\cdot t $ \\]","title":"\ud83d\udd39 Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"The vertical motion is governed by constant acceleration due to gravity \\($ g \\) : \\[ $ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $ \\] The projectile reaches the ground when \\($ y = 0 $\\) , solving for \\($ t $\\) : \\[ $ t_f = \\frac{2 v_0 \\sin\\theta}{g} $ \\] This is the total time of flight .","title":"\ud83d\udd39 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\($ R \\) is the horizontal distance covered by the projectile when it lands: \\[ $ R = x(t_f) = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} $\\] Using the identity \\($ 2\\sin\\theta\\cos\\theta = \\sin 2\\theta $\\) , we get: \\[ R = $\\frac{v_0^2}{g} \\sin 2\\theta $ \\]","title":"\ud83d\udccf 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Maximum Range: The range is maximized when \\($ \\sin 2\\theta = 1 $\\) , i.e., \\($ 2\\theta = 90^\\circ $\\) \u2192 \\($ \\theta = 45^\\circ $\\) . Symmetry: The function \\($ R(\\theta) $\\) is symmetric around \\($ 45^\\circ $\\) , meaning \\($ R(\\theta) = R(90^\\circ - \\theta) $\\) . Effect of Initial Velocity: Since \\($ R \\propto v_0^2 $\\) , doubling \\($ v_0 $\\) quadruples the range. Effect of Gravity: Since \\($ R \\propto \\frac{1}{g} $\\) , projectiles travel farther on planets with lower gravity (e.g., the Moon).","title":"\ud83d\udccc Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Soccer: Kicking a ball at \\($ 45^\\circ $\\) for maximum distance. Basketball: Analyzing the optimal shooting angle. Engineering & Ballistics: Missile trajectories and range optimization. Water fountains and fluid mechanics. Astrophysics: Moon landings require adjusting launch angles based on gravity.","title":"\ud83c\udf0e 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"","title":"\ud83d\udcbb 4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graph-interpretation","text":"The maximum range occurs at \u03b8 = 45\u00b0 The function is symmetric about 45\u00b0 Higher v\u2080 increases range quadratically","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-of-the-model","text":"Assumes no air resistance Assumes flat terrain (ignores hills, obstacles) Ignores wind effects , which can alter trajectories","title":"\ud83d\udd39 Limitations of the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#enhancements","text":"Add air drag to create more realistic simulations Consider launches from elevated platforms (e.g., artillery firing from a hill) Visit My Collab import numpy as np import matplotlib.pyplot as plt # Gravitational acceleration g = 9.81 # Function to plot the trajectory def trajectory(v0, angle_deg): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Graph (a) plt.figure(figsize=(12, 10)) plt.subplot(2, 1, 1) for v0, color in zip([30, 40, 50], ['red', 'purple', 'green']): x, y = trajectory(v0, 45) plt.plot(x, y, color=color, label=f'{v0} m/s') plt.title('(a) Same angle (45\u00b0), different speeds') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(91.8, color='black', linestyle='--') plt.axvline(163, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 70) # Graph (b) plt.subplot(2, 1, 2) v0 = 50 for angle, color in zip([15, 45, 75], ['red', 'purple', 'green']): x, y = trajectory(v0, angle) plt.plot(x, y, color=color, label=f'{angle}\u00b0') plt.title('(b) Same speed (50 m/s), different angles') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(128, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 130) plt.tight_layout() plt.show()","title":"\ud83d\udd39 Enhancements"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis","text":"","title":"\ud83c\udfaf Projectile Motion Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graph-a-different-initial-speeds-same-angle-45","text":"Launch angle: 45\u00b0 \u2014 this is the optimal angle for achieving maximum range when the initial speed is fixed. Initial speeds: - 30 m/s (\ud83d\udd34 red trajectory) - 40 m/s (\ud83d\udfe3 purple trajectory) - 50 m/s (\ud83d\udfe2 green trajectory) Conclusion: The greater the initial speed (with a fixed angle), the farther the projectile travels. Example ranges (R): - 30 m/s \u2192 R \u2248 91.8 m - 40 m/s \u2192 R \u2248 163 m - 50 m/s \u2192 R \u2248 255 m","title":"\ud83d\udcca Graph (a): Different Initial Speeds, Same Angle (45\u00b0)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"R = (v\u2080\u00b2 * sin(2\u03b8)) / g When \u03b8 = 45\u00b0 , sin(2\u03b8) = sin(90\u00b0) = 1 \u2192 So the range depends only on v\u2080\u00b2 .","title":"\ud83d\udccc Range formula:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graph-b-same-initial-speed-50-ms-different-angles","text":"Initial speed: 50 m/s for all three trajectories. Angles: - 15\u00b0 (\ud83d\udd34 red): low trajectory, small height and short range. - 45\u00b0 (\ud83d\udfe3 purple): maximum range. - 75\u00b0 (\ud83d\udfe2 green): high trajectory, but shorter range. Interesting fact: 15\u00b0 and 75\u00b0 give equal range ( R \u2248 128 m ), even though the shapes of the trajectories are very different.","title":"\ud83d\udcca Graph (b): Same Initial Speed (50 m/s), Different Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#symmetry-law","text":"Angles \u03b8 and 90\u00b0 \u2212 \u03b8 give the same range, because: sin(2\u03b8) = sin(2(90\u00b0 \u2212 \u03b8)) = sin(180\u00b0 \u2212 2\u03b8) = sin(2\u03b8)","title":"\ud83d\udccc Symmetry Law:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#main-takeaways","text":"The best angle for maximum range with a given speed is 45\u00b0 . With the same angle, higher speed means greater range. Angles that add up to 90\u00b0 (like 15\u00b0 and 75\u00b0 ) give the same range, but different heights and flight paths. Visit My Collab import numpy as np import matplotlib.pyplot as plt # Gravitational acceleration g = 9.81 # Function to plot the trajectory def trajectory(v0, angle_deg): angle_rad = np.radians(angle_deg) t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Graph (a) plt.figure(figsize=(12, 10)) plt.subplot(2, 1, 1) for v0, color in zip([30, 40, 50], ['red', 'purple', 'green']): x, y = trajectory(v0, 45) plt.plot(x, y, color=color, label=f'{v0} m/s') plt.title('(a) Same angle (45\u00b0), different speeds') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(91.8, color='black', linestyle='--') plt.axvline(163, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 70) # Graph (b) plt.subplot(2, 1, 2) v0 = 50 for angle, color in zip([15, 45, 75], ['red', 'purple', 'green']): x, y = trajectory(v0, angle) plt.plot(x, y, color=color, label=f'{angle}\u00b0') plt.title('(b) Same speed (50 m/s), different angles') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.grid(True) plt.legend() plt.axvline(128, color='black', linestyle='--') plt.axvline(255, color='black', linestyle='--') plt.xlim(0, 270) plt.ylim(0, 130) plt.tight_layout() plt.show()","title":"\ud83e\udde0 Main Takeaways:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83d\udccc Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfd7 Motivation The forced damped pendulum is a fascinating system that exhibits a range of behaviors, from simple oscillations to chaotic motion. By introducing damping and an external periodic force, we observe a transition from regular periodic motion to resonance, quasiperiodicity, and chaos . This system is crucial for understanding: - Resonance in mechanical systems (e.g., bridges, buildings under periodic stress). - Nonlinear dynamics and chaos theory (e.g., weather patterns, heart rhythms). - Energy harvesting from oscillations. \u2696 1. Theoretical Foundation \ud83d\udcdc Equation of Motion The forced damped pendulum follows the nonlinear differential equation: \\[ $ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) $ \\] where: - \\($ \\theta $\\) = angular displacement - \\($ \\gamma $\\) = damping coefficient - \\($ \\omega_0$ \\) = natural frequency of the pendulum ( \\($ \\omega_0 = \\sqrt{\\frac{g}{L}} $\\) ) - \\($ A $\\) = amplitude of the external driving force - \\($ \\omega $\\) = driving frequency For small angles ( \\($ \\theta \\approx \\sin\\theta $\\) ), the equation simplifies to: \\[ $ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) $ \\] which resembles the equation of a driven damped harmonic oscillator . \ud83d\udccc Resonance Condition Resonance occurs when the driving frequency \\($ \\omega $\\) matches the natural frequency \\($ \\omega_0 $\\) , leading to maximum energy absorption and large oscillations: \\[ $ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}} $ \\] At resonance, even small driving forces can produce large oscillations, which is crucial in mechanical engineering and structural safety . \ud83d\udcca 2. Analysis of Dynamics \ud83d\udd39 Effect of Damping ( \\($ \\gamma $\\) ) Low damping: The pendulum exhibits large oscillations and resonance. High damping: The system stabilizes quickly with reduced oscillations. \ud83d\udd39 Effect of Driving Amplitude ( \\($ A $\\) ) Low amplitude: The pendulum undergoes periodic motion. High amplitude: The system transitions into chaotic motion for certain frequencies. \ud83d\udd39 Effect of Driving Frequency ( \\($ \\omega $\\) ) When \\( $\\omega \\approx \\omega_0 $\\) , resonance occurs. When \\($ \\omega $\\) is far from \\($ \\omega_0 $\\) , the response is weak. Nonlinear behavior emerges at certain parameter values, leading to chaos. \ud83c\udf0d 3. Practical Applications Engineering & Structural Dynamics Bridges & Skyscrapers: Understanding how periodic forces (e.g., wind, earthquakes) affect large structures. Vibration Isolation: Designing materials that minimize resonance effects. Energy Harvesting Pendulum-based generators: Extracting energy from periodic motion. Ocean wave energy devices. Chaos Theory & Climate Models Weather prediction models involve nonlinear oscillatory behaviors similar to the forced pendulum. \ud83d\udcbb 4. Implementation (Python Simulation) \ud83c\udf00 Forced Damped Pendulum \u2013 Graph Explanations This document explains the results of simulating different types of pendulum motion using Python. Each case includes plots of: - Angle vs. Time - Phase Diagram (Angle vs. Angular Velocity) \ud83d\udd39 1) Simple Pendulum Parameters: - Damping: b = 0 - External Force: A = 0 Explanation: - This is an ideal pendulum with no friction and no external driving force. - The angle oscillates sinusoidally \u2014 classic harmonic motion. - The phase portrait shows a closed elliptical trajectory , indicating periodic motion with constant energy. - This case illustrates the basics of classical mechanics. \ud83d\udd39 2) Damped Pendulum Parameters: - Damping: b > 0 - External Force: A = 0 Explanation: - The pendulum loses energy over time due to friction. - The amplitude of oscillation gradually decreases until the system comes to rest. - The phase portrait shows a spiral converging to the center , representing damped oscillations . - Eventually, the pendulum reaches equilibrium. \ud83d\udd39 3) Forced Pendulum Parameters: - Damping: b = 0 - External Force: A \u2260 0 , \u03c9 \u2260 0 Explanation: - The pendulum is driven by an external periodic force. - The motion becomes non-periodic and more complex , with varying amplitude. - The phase portrait displays non-closed loops , indicating the pendulum is constantly gaining energy from the driving force. - Demonstrates unstable behavior under continuous forcing. \ud83d\udd39 4) Forced Damped Pendulum Parameters: - Damping: b > 0 - External Force: A \u2260 0 Explanation: - A combination of friction and periodic forcing leads to stable oscillations with limited amplitude . - The amplitude grows initially, then settles into a steady state. - The phase portrait shows a stable closed loop , indicating synchronization with the external force . - Very important for understanding resonant systems in engineering . \ud83d\udd39 5) Chaotic / Resonant Pendulum Parameters: - Damping: b > 0 - Driving Force: A is large, \u03c9 is near resonance Explanation: - This system exhibits chaotic or resonant behavior . - The angle varies unpredictably, with no fixed frequency or amplitude. - The phase portrait shows a complicated, tangled structure , characteristic of chaotic systems . - Demonstrates how deterministic systems can behave unpredictably . \ud83e\udde0 Summary These five cases demonstrate the full spectrum of pendulum dynamics \u2014 from regular harmonic motion to complex chaotic behavior. They highlight key physical phenomena: - \u2705 Harmonic motion - \u2705 Damping and energy loss - \u2705 Forced synchronization - \u2705 Chaos and unpredictability Visit My Collab import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # \u0423\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u044f\u0442\u043d\u0438\u043a\u0430: d\u00b2\u03b8/dt\u00b2 + b*d\u03b8/dt + sin(\u03b8) = A*cos(\u03c9*t) def pendulum(t, y, b, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f: \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u03b8(t) \u0438 (\u03b8, \u03c9) def plot_pendulum(t, sol, title, color): theta = sol[0] omega = sol[1] fig, ax = plt.subplots(1, 2, figsize=(14, 4)) fig.suptitle(title, fontsize=16) ax[0].plot(t, theta, color=color) ax[0].set_title(\"Time Series\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Angle (rad)\") ax[0].grid(True) ax[1].plot(theta, omega, color=color) ax[1].set_title(\"Phase Portrait\") ax[1].set_xlabel(\"\u03b8 (rad)\") ax[1].set_ylabel(\"\u03c9 (rad/s)\") ax[1].grid(True) plt.tight_layout() plt.subplots_adjust(top=0.85) # \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043d\u0435 \u043d\u0430\u043b\u0435\u0437\u0430\u043b plt.show() # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f t_span = (0, 30) t_eval = np.linspace(*t_span, 2000) initial_state = [0.1, 0.0] # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u0443\u0433\u043e\u043b \u0438 \u0443\u0433\u043b\u043e\u0432\u0430\u044f \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c # ===== 1. Simple Pendulum ===== sol1 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 0.0, 0.0)) plot_pendulum(sol1.t, sol1.y, \"1) Simple Pendulum (b=0, A=0)\", \"crimson\") # ===== 2. Damped Pendulum ===== sol2 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 0.0, 0.0)) plot_pendulum(sol2.t, sol2.y, \"2) Damped Pendulum (b=0.5, A=0)\", \"darkblue\") # ===== 3. Forced Pendulum ===== sol3 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 1.0, 2.0)) plot_pendulum(sol3.t, sol3.y, \"3) Forced Pendulum (b=0, A=1.0, \u03c9=2.0)\", \"teal\") # ===== 4. Forced Damped Pendulum ===== sol4 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.2, 1.2, 2.0)) plot_pendulum(sol4.t, sol4.y, \"4) Forced Damped Pendulum (b=0.2, A=1.2, \u03c9=2.0)\", \"orange\") # ===== 5. Chaotic / Resonant Pendulum ===== sol5 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 1.5, 2/3)) plot_pendulum(sol5.t, sol5.y, \"5) Chaotic / Resonant Pendulum (b=0.5, A=1.5, \u03c9=2/3)\", \"firebrick\")","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83d\udccc Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating system that exhibits a range of behaviors, from simple oscillations to chaotic motion. By introducing damping and an external periodic force, we observe a transition from regular periodic motion to resonance, quasiperiodicity, and chaos . This system is crucial for understanding: - Resonance in mechanical systems (e.g., bridges, buildings under periodic stress). - Nonlinear dynamics and chaos theory (e.g., weather patterns, heart rhythms). - Energy harvesting from oscillations.","title":"\ud83c\udfd7 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"The forced damped pendulum follows the nonlinear differential equation: \\[ $ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) $ \\] where: - \\($ \\theta $\\) = angular displacement - \\($ \\gamma $\\) = damping coefficient - \\($ \\omega_0$ \\) = natural frequency of the pendulum ( \\($ \\omega_0 = \\sqrt{\\frac{g}{L}} $\\) ) - \\($ A $\\) = amplitude of the external driving force - \\($ \\omega $\\) = driving frequency For small angles ( \\($ \\theta \\approx \\sin\\theta $\\) ), the equation simplifies to: \\[ $ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) $ \\] which resembles the equation of a driven damped harmonic oscillator .","title":"\ud83d\udcdc Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\($ \\omega $\\) matches the natural frequency \\($ \\omega_0 $\\) , leading to maximum energy absorption and large oscillations: \\[ $ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}} $ \\] At resonance, even small driving forces can produce large oscillations, which is crucial in mechanical engineering and structural safety .","title":"\ud83d\udccc Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"\ud83d\udcca 2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping-gamma","text":"Low damping: The pendulum exhibits large oscillations and resonance. High damping: The system stabilizes quickly with reduced oscillations.","title":"\ud83d\udd39 Effect of Damping (\\($ \\gamma $\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-amplitude-a","text":"Low amplitude: The pendulum undergoes periodic motion. High amplitude: The system transitions into chaotic motion for certain frequencies.","title":"\ud83d\udd39 Effect of Driving Amplitude (\\($ A $\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-frequency-omega","text":"When \\( $\\omega \\approx \\omega_0 $\\) , resonance occurs. When \\($ \\omega $\\) is far from \\($ \\omega_0 $\\) , the response is weak. Nonlinear behavior emerges at certain parameter values, leading to chaos.","title":"\ud83d\udd39 Effect of Driving Frequency (\\($ \\omega $\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Engineering & Structural Dynamics Bridges & Skyscrapers: Understanding how periodic forces (e.g., wind, earthquakes) affect large structures. Vibration Isolation: Designing materials that minimize resonance effects. Energy Harvesting Pendulum-based generators: Extracting energy from periodic motion. Ocean wave energy devices. Chaos Theory & Climate Models Weather prediction models involve nonlinear oscillatory behaviors similar to the forced pendulum.","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"","title":"\ud83d\udcbb 4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-graph-explanations","text":"This document explains the results of simulating different types of pendulum motion using Python. Each case includes plots of: - Angle vs. Time - Phase Diagram (Angle vs. Angular Velocity)","title":"\ud83c\udf00 Forced Damped Pendulum \u2013 Graph Explanations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-simple-pendulum","text":"Parameters: - Damping: b = 0 - External Force: A = 0 Explanation: - This is an ideal pendulum with no friction and no external driving force. - The angle oscillates sinusoidally \u2014 classic harmonic motion. - The phase portrait shows a closed elliptical trajectory , indicating periodic motion with constant energy. - This case illustrates the basics of classical mechanics.","title":"\ud83d\udd39 1) Simple Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-damped-pendulum","text":"Parameters: - Damping: b > 0 - External Force: A = 0 Explanation: - The pendulum loses energy over time due to friction. - The amplitude of oscillation gradually decreases until the system comes to rest. - The phase portrait shows a spiral converging to the center , representing damped oscillations . - Eventually, the pendulum reaches equilibrium.","title":"\ud83d\udd39 2) Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-forced-pendulum","text":"Parameters: - Damping: b = 0 - External Force: A \u2260 0 , \u03c9 \u2260 0 Explanation: - The pendulum is driven by an external periodic force. - The motion becomes non-periodic and more complex , with varying amplitude. - The phase portrait displays non-closed loops , indicating the pendulum is constantly gaining energy from the driving force. - Demonstrates unstable behavior under continuous forcing.","title":"\ud83d\udd39 3) Forced Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-forced-damped-pendulum","text":"Parameters: - Damping: b > 0 - External Force: A \u2260 0 Explanation: - A combination of friction and periodic forcing leads to stable oscillations with limited amplitude . - The amplitude grows initially, then settles into a steady state. - The phase portrait shows a stable closed loop , indicating synchronization with the external force . - Very important for understanding resonant systems in engineering .","title":"\ud83d\udd39 4) Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-chaotic-resonant-pendulum","text":"Parameters: - Damping: b > 0 - Driving Force: A is large, \u03c9 is near resonance Explanation: - This system exhibits chaotic or resonant behavior . - The angle varies unpredictably, with no fixed frequency or amplitude. - The phase portrait shows a complicated, tangled structure , characteristic of chaotic systems . - Demonstrates how deterministic systems can behave unpredictably .","title":"\ud83d\udd39 5) Chaotic / Resonant Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"These five cases demonstrate the full spectrum of pendulum dynamics \u2014 from regular harmonic motion to complex chaotic behavior. They highlight key physical phenomena: - \u2705 Harmonic motion - \u2705 Damping and energy loss - \u2705 Forced synchronization - \u2705 Chaos and unpredictability Visit My Collab import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # \u0423\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u044f\u0442\u043d\u0438\u043a\u0430: d\u00b2\u03b8/dt\u00b2 + b*d\u03b8/dt + sin(\u03b8) = A*cos(\u03c9*t) def pendulum(t, y, b, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f: \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u03b8(t) \u0438 (\u03b8, \u03c9) def plot_pendulum(t, sol, title, color): theta = sol[0] omega = sol[1] fig, ax = plt.subplots(1, 2, figsize=(14, 4)) fig.suptitle(title, fontsize=16) ax[0].plot(t, theta, color=color) ax[0].set_title(\"Time Series\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Angle (rad)\") ax[0].grid(True) ax[1].plot(theta, omega, color=color) ax[1].set_title(\"Phase Portrait\") ax[1].set_xlabel(\"\u03b8 (rad)\") ax[1].set_ylabel(\"\u03c9 (rad/s)\") ax[1].grid(True) plt.tight_layout() plt.subplots_adjust(top=0.85) # \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043d\u0435 \u043d\u0430\u043b\u0435\u0437\u0430\u043b plt.show() # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f t_span = (0, 30) t_eval = np.linspace(*t_span, 2000) initial_state = [0.1, 0.0] # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u0443\u0433\u043e\u043b \u0438 \u0443\u0433\u043b\u043e\u0432\u0430\u044f \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c # ===== 1. Simple Pendulum ===== sol1 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 0.0, 0.0)) plot_pendulum(sol1.t, sol1.y, \"1) Simple Pendulum (b=0, A=0)\", \"crimson\") # ===== 2. Damped Pendulum ===== sol2 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 0.0, 0.0)) plot_pendulum(sol2.t, sol2.y, \"2) Damped Pendulum (b=0.5, A=0)\", \"darkblue\") # ===== 3. Forced Pendulum ===== sol3 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 1.0, 2.0)) plot_pendulum(sol3.t, sol3.y, \"3) Forced Pendulum (b=0, A=1.0, \u03c9=2.0)\", \"teal\") # ===== 4. Forced Damped Pendulum ===== sol4 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.2, 1.2, 2.0)) plot_pendulum(sol4.t, sol4.y, \"4) Forced Damped Pendulum (b=0.2, A=1.2, \u03c9=2.0)\", \"orange\") # ===== 5. Chaotic / Resonant Pendulum ===== sol5 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 1.5, 2/3)) plot_pendulum(sol5.t, sol5.y, \"5) Chaotic / Resonant Pendulum (b=0.5, A=1.5, \u03c9=2/3)\", \"firebrick\")","title":"\ud83e\udde0 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83c\udf0d Orbital Period and Orbital Radius \ud83c\udfd7 Motivation Kepler's Third Law is a fundamental principle of celestial mechanics, stating that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius. This law, derived from Newton's Law of Universal Gravitation , is crucial for: - Understanding planetary motion and exoplanet detection - Designing satellite orbits - Calculating masses of celestial bodies By deriving and simulating this relationship, we gain insight into the governing laws of planetary systems. \u2696 1. Theoretical Foundation \ud83d\udcdc Derivation of Kepler\u2019s Third Law \ud83c\udf0d Circular Orbits and Kepler\u2019s Third Law For a body in circular orbit around a much larger mass (e.g., a planet around a star), the gravitational force provides the necessary centripetal force : \\[ $F_{\\text{gravity}} = F_{\\text{centripetal}}$ \\] \ud83d\udd39 Newton\u2019s Law of Gravitation \\[ $F_{\\text{gravity}} = \\frac{G M m}{r^2}$ \\] Where: - \\( G \\) = Gravitational constant \\( $(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}) $\\) - \\( M \\) = Mass of the central body (e.g., Sun, Earth) - \\( m \\) = Mass of the orbiting body - \\( r \\) = Orbital radius \ud83d\udd39 Centripetal Force \\[ $F_{\\text{centripetal}} = \\frac{m v^2}{r}$ \\] Equating both forces: \\[ $\\frac{G M m}{r^2} = \\frac{m v^2}{r}$ \\] Cancel \\( m \\) , and solve for \\( v \\) : \\[ v = $\\sqrt{\\frac{G M}{r}}$ \\] \ud83d\udd39 Orbital Period The orbital period \\( T \\) is the time to complete one full orbit: \\[ T = $\\frac{2\\pi r}{v}$ \\] Substitute velocity: \\[ T = $\\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}}$ \\] \u2705 Kepler\u2019s Third Law (Final Form) \\[ T^2 = $\\frac{4\\pi^2}{G M} r^3$ \\] This shows: \\[ T^2 $\\propto r^3$ \\] ] \ud83d\udd39 Implications: - Larger orbits = Longer periods - Planets farther from the Sun move slower - The mass of the central body can be determined from orbital data \ud83c\udf0d 2. Real-World Examples 1. Earth's Moon Distance: \\( r = 3.844 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days Using Kepler\u2019s Law, we can estimate Earth\u2019s mass. 2. Planets in the Solar System If we take Earth\u2019s orbit as a reference ( \\( r = 1 \\) AU, \\( T = 1 \\) year), then for any planet: \\[ $\\frac{T_{\\text{planet}}^2}{r_{\\text{planet}}^3} \\approx 1$ \\] This relationship helps predict unknown orbital parameters of newly discovered planets. \ud83d\udcbb 3. Implementation (Python Simulation) We\u2019ll verify Kepler\u2019s Third Law using numerical simulations. \ud83d\udccc Step 1: Install Dependencies Ensure NumPy and Matplotlib are installed: bash pip install numpy matplotlib \ud83d\udccc Step 2: Python Code for Simulation Visit My Collab import numpy as np import matplotlib.pyplot as plt # Planet data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T_years = [0.2408, 0.6152, 1.000, 1.8808] # Orbital periods in Earth years a_AU = [0.387, 0.723, 1.000, 1.524] # Semi-major axes in astronomical units (AU) # Calculate T^2 and a^3 T_squared = [T**2 for T in T_years] a_cubed = [a**3 for a in a_AU] # Plotting the graph plt.figure(figsize=(8, 6)) plt.plot(a_cubed, T_squared, 'o-', color='dodgerblue', label='Planets') # Annotate each planet for i, name in enumerate(planets): plt.text(a_cubed[i] * 1.02, T_squared[i] * 0.98, name) # Add labels, title, grid, and reference line plt.title(\"Kepler's 3rd Law: $T^2$ vs $a^3$\", fontsize=14) plt.xlabel(\"$a^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (Years\u00b2)\", fontsize=12) plt.grid(True) # Expected reference line with slope = 1 (perfect linear relation) plt.axline((0, 0), slope=1, color='gray', linestyle='--', label='Expected line (slope = 1)') plt.legend() plt.tight_layout() plt.show() \ud83d\udcca 4. Results and Discussion \ud83d\udd39 Graph Interpretation The data points align with a straight line , confirming \\( T^2 \\propto r^3 \\) . The best-fit line follows Kepler\u2019s predicted trend , verifying the law experimentally. \ud83d\udd39 Applications of Kepler\u2019s Law Finding Exoplanets: Measuring a planet\u2019s orbital period allows astronomers to estimate its distance from its star . Space Missions: Used in designing satellite orbits (e.g., GPS, geostationary satellites). \ud83d\udd39 Limitations Kepler\u2019s Law assumes circular orbits, but real orbits are elliptical . External forces (e.g., other planets\u2019 gravity) can slightly alter orbits . Got it \u2014 you want a Markdown version with nice formatting, clear explanations, and using LaTeX-style math ( $$ ) for all formulas. Here's the full Markdown version you can paste into Google Colab or Jupyter Notebook: Using Kepler's Law to Find the Mass of the Earth and the Sun 1. Kepler\u2019s Third Law Rearranging the Kepler formula to find the mass \\( M \\) : \\[ M = \\frac{4\\pi^2 R^3}{G T^2} \\] 2. Finding the Mass of the Sun The Earth\u2019s orbit around the Sun has: - Radius \\(R = 1.496 \\times 10^{11} \\, \\text{m}\\) (1 Astronomical Unit), - Period \\(T = 365.25 \\times 24 \\times 3600 \\, \\text{seconds}\\) . Substituting into the formul gives: \\[ M_{\\text{sun}} \\approx 1.99 \\times 10^{30} \\, \\text{kg} \\] \u2705 This matches the known value for the mass of the Sun! 3. Finding the Mass of the Earth The Moon orbits Earth with: - Radius \\($ R = 3.844 \\times 10^{8} \\, \\text{m}$ \\) , - Period \\($ T = 27.32 \\times 24 \\times 3600 \\, \\text{seconds}$ \\) . Substituting into the formula: \\[ M_{\\text{earth}} = \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{6.67430 \\times 10^{-11} (27.32 \\times 24 \\times 3600)^2} \\approx 5.97 \\times 10^{24} \\, \\text{kg} \\]","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"\ud83c\udf0d Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law is a fundamental principle of celestial mechanics, stating that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius. This law, derived from Newton's Law of Universal Gravitation , is crucial for: - Understanding planetary motion and exoplanet detection - Designing satellite orbits - Calculating masses of celestial bodies By deriving and simulating this relationship, we gain insight into the governing laws of planetary systems.","title":"\ud83c\udfd7 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"","title":"\ud83d\udcdc Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-orbits-and-keplers-third-law","text":"For a body in circular orbit around a much larger mass (e.g., a planet around a star), the gravitational force provides the necessary centripetal force : \\[ $F_{\\text{gravity}} = F_{\\text{centripetal}}$ \\]","title":"\ud83c\udf0d Circular Orbits and Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-gravitation","text":"\\[ $F_{\\text{gravity}} = \\frac{G M m}{r^2}$ \\] Where: - \\( G \\) = Gravitational constant \\( $(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}) $\\) - \\( M \\) = Mass of the central body (e.g., Sun, Earth) - \\( m \\) = Mass of the orbiting body - \\( r \\) = Orbital radius","title":"\ud83d\udd39 Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force","text":"\\[ $F_{\\text{centripetal}} = \\frac{m v^2}{r}$ \\] Equating both forces: \\[ $\\frac{G M m}{r^2} = \\frac{m v^2}{r}$ \\] Cancel \\( m \\) , and solve for \\( v \\) : \\[ v = $\\sqrt{\\frac{G M}{r}}$ \\]","title":"\ud83d\udd39 Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period","text":"The orbital period \\( T \\) is the time to complete one full orbit: \\[ T = $\\frac{2\\pi r}{v}$ \\] Substitute velocity: \\[ T = $\\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}}$ \\]","title":"\ud83d\udd39 Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-final-form","text":"\\[ T^2 = $\\frac{4\\pi^2}{G M} r^3$ \\] This shows: \\[ T^2 $\\propto r^3$ \\] ] \ud83d\udd39 Implications: - Larger orbits = Longer periods - Planets farther from the Sun move slower - The mass of the central body can be determined from orbital data","title":"\u2705 Kepler\u2019s Third Law (Final Form)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-examples","text":"","title":"\ud83c\udf0d 2. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-earths-moon","text":"Distance: \\( r = 3.844 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days Using Kepler\u2019s Law, we can estimate Earth\u2019s mass.","title":"1. Earth's Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-planets-in-the-solar-system","text":"If we take Earth\u2019s orbit as a reference ( \\( r = 1 \\) AU, \\( T = 1 \\) year), then for any planet: \\[ $\\frac{T_{\\text{planet}}^2}{r_{\\text{planet}}^3} \\approx 1$ \\] This relationship helps predict unknown orbital parameters of newly discovered planets.","title":"2. Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-implementation-python-simulation","text":"We\u2019ll verify Kepler\u2019s Third Law using numerical simulations.","title":"\ud83d\udcbb 3. Implementation (Python Simulation)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-install-dependencies","text":"Ensure NumPy and Matplotlib are installed: bash pip install numpy matplotlib","title":"\ud83d\udccc Step 1: Install Dependencies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-python-code-for-simulation","text":"Visit My Collab import numpy as np import matplotlib.pyplot as plt # Planet data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T_years = [0.2408, 0.6152, 1.000, 1.8808] # Orbital periods in Earth years a_AU = [0.387, 0.723, 1.000, 1.524] # Semi-major axes in astronomical units (AU) # Calculate T^2 and a^3 T_squared = [T**2 for T in T_years] a_cubed = [a**3 for a in a_AU] # Plotting the graph plt.figure(figsize=(8, 6)) plt.plot(a_cubed, T_squared, 'o-', color='dodgerblue', label='Planets') # Annotate each planet for i, name in enumerate(planets): plt.text(a_cubed[i] * 1.02, T_squared[i] * 0.98, name) # Add labels, title, grid, and reference line plt.title(\"Kepler's 3rd Law: $T^2$ vs $a^3$\", fontsize=14) plt.xlabel(\"$a^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (Years\u00b2)\", fontsize=12) plt.grid(True) # Expected reference line with slope = 1 (perfect linear relation) plt.axline((0, 0), slope=1, color='gray', linestyle='--', label='Expected line (slope = 1)') plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udccc Step 2: Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-results-and-discussion","text":"","title":"\ud83d\udcca 4. Results and Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-interpretation","text":"The data points align with a straight line , confirming \\( T^2 \\propto r^3 \\) . The best-fit line follows Kepler\u2019s predicted trend , verifying the law experimentally.","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-of-keplers-law","text":"Finding Exoplanets: Measuring a planet\u2019s orbital period allows astronomers to estimate its distance from its star . Space Missions: Used in designing satellite orbits (e.g., GPS, geostationary satellites).","title":"\ud83d\udd39 Applications of Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#limitations","text":"Kepler\u2019s Law assumes circular orbits, but real orbits are elliptical . External forces (e.g., other planets\u2019 gravity) can slightly alter orbits . Got it \u2014 you want a Markdown version with nice formatting, clear explanations, and using LaTeX-style math ( $$ ) for all formulas. Here's the full Markdown version you can paste into Google Colab or Jupyter Notebook:","title":"\ud83d\udd39 Limitations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#using-keplers-law-to-find-the-mass-of-the-earth-and-the-sun","text":"","title":"Using Kepler's Law to Find the Mass of the Earth and the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-keplers-third-law","text":"Rearranging the Kepler formula to find the mass \\( M \\) : \\[ M = \\frac{4\\pi^2 R^3}{G T^2} \\]","title":"1. Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-finding-the-mass-of-the-sun","text":"The Earth\u2019s orbit around the Sun has: - Radius \\(R = 1.496 \\times 10^{11} \\, \\text{m}\\) (1 Astronomical Unit), - Period \\(T = 365.25 \\times 24 \\times 3600 \\, \\text{seconds}\\) . Substituting into the formul gives: \\[ M_{\\text{sun}} \\approx 1.99 \\times 10^{30} \\, \\text{kg} \\] \u2705 This matches the known value for the mass of the Sun!","title":"2. Finding the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-finding-the-mass-of-the-earth","text":"The Moon orbits Earth with: - Radius \\($ R = 3.844 \\times 10^{8} \\, \\text{m}$ \\) , - Period \\($ T = 27.32 \\times 24 \\times 3600 \\, \\text{seconds}$ \\) . Substituting into the formula: \\[ M_{\\text{earth}} = \\frac{4\\pi^2 (3.844 \\times 10^8)^3}{6.67430 \\times 10^{-11} (27.32 \\times 24 \\times 3600)^2} \\approx 5.97 \\times 10^{24} \\, \\text{kg} \\]","title":"3. Finding the Mass of the Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 \u2139\ufe0f Why the \"Motivation\" and \"Why Cosmic Velocities Matter\" Sections are Important \ud83d\udcd8 Motivation \ud83d\udd39 What is it? This section explains why the topic is important , why it matters, and where it is applied. \ud83d\udd39 Why is it needed? Helps the reader get into the topic . Explains why cosmic velocities are important to study . Makes the project more meaningful and complete . Answers the question: \"Why should I care about this?\" \ud83d\udd39 Alternative If you want, you can replace it with a short introduction like: This work discusses the speeds needed to reach orbit, escape a planet's gravity, and leave the solar system. \u2753 Why Cosmic Velocities Matter \ud83d\udd39 What is it? This concluding section shows the practical value of the entire work. \ud83d\udd39 Why is it needed? Connects formulas and calculations with real-life applications . Shows where they are used: First cosmic velocity \u2014 for satellites and orbits. Second cosmic velocity \u2014 for missions to the Moon and Mars. Third cosmic velocity \u2014 for missions beyond the solar system (e.g., Voyager). \ud83d\udd39 Benefits for the project Helps understand the meaning behind the calculations . Makes the report complete and logical . Creates a better impression during the defense . \ud83d\udd39 How to simplify it These velocities are important for space exploration because they help us understand the speeds required to launch satellites, send rockets to other planets, or even beyond the solar system. \u2705 These sections make your work not just \"formula-based\" but meaningful and engaging . \ud83d\ude80 Cosmic Velocities and Escape Velocities \ud83d\udcd8 What Are Cosmic Velocities? Cosmic velocities are speeds needed to move around or escape a celestial body: First Cosmic Velocity (v\u2081) : To orbit the body in a circle (like satellites). Second Cosmic Velocity (v\u2082) : To escape its gravity (like flying to space). Third Cosmic Velocity (v\u2083) : To leave the Solar System. \ud83e\udde0 Derivations 1\ufe0f\u20e3 First Cosmic Velocity \\( v_1 \\) Meaning : Minimum speed to orbit just above the surface. Derivation: Centripetal force: $$ F = \\frac{m \\cdot v^2}{r} $$ Gravitational force: $$ F = \\frac{G \\cdot M \\cdot m}{r^2} $$ Equating: \\[ \\frac{m \\cdot v^2}{r} = \\frac{G \\cdot M \\cdot m}{r^2} \\] Cancelling \\( m \\) and solving: \\[ v_1 = \\sqrt{\\frac{G \\cdot M}{r}} \\] 2\ufe0f\u20e3 Second Cosmic Velocity \\( v_2 \\) Meaning : Minimum speed to escape a planet's gravity. Derivation: From energy conservation: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\] Solving: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} = \\sqrt{2} \\cdot v_1 \\] 3\ufe0f\u20e3 Third Cosmic Velocity \\( v_3 \\) Meaning : Speed to escape the Sun starting from Earth\u2019s orbit. Formula: \\[ v_3 = \\sqrt{\\frac{2 G M_{sun}}{r_{orbit}}} \\] \ud83c\udf0d Earth: Example Values \\($ G = 6.674 \\cdot 10^{-11} \\, \\text{m}^3/\\text{kg s}^2 $\\) \\($ M = 5.972 \\cdot 10^{24} \\, \\text{kg} $\\) \\($ r = 6.371 \\cdot 10^6 \\, \\text{m} $\\) \\($ M_{sun} = 1.989 \\cdot 10^{30} \\, \\text{kg}$ \\) \\($ r_{earth\\ orbit} = 1.496 \\cdot 10^{11} \\, \\text{m} $\\) Calculated: \\($ v_1 \\approx 7.9 \\, \\text{km/s} $\\) \\($ v_2 \\approx 11.2 \\, \\text{km/s} $\\) \\($ v_3 \\approx 42.1 \\, \\text{km/s} $\\) \ud83c\udf0c Comparison Table Celestial Body Mass (kg) Radius (m) \\( v_1 \\) (km/s) \\( v_2 \\) (km/s) Moon \\($7.35 \\cdot 10^{22}$\\) \\($1.74 \\cdot 10^6$\\) 1.68 2.38 Earth \\($5.97 \\cdot 10^{24}$\\) \\($6.37 \\cdot 10^6$\\) 7.9 11.2 Mars \\($6.42 \\cdot 10^{23}$\\) \\($3.39 \\cdot 10^6$\\) 3.6 5.0 Jupiter \\($1.90 \\cdot 10^{27}$\\) \\($6.99 \\cdot 10^7$\\) 42.1 59.5 \ud83d\udcca Visualization (Python) Visit My Collab import matplotlib.pyplot as plt bodies = [\"Moon\", \"Earth\", \"Mars\", \"Jupiter\"] v1 = [1.68, 7.9, 3.6, 42.1] v2 = [2.38, 11.2, 5.0, 59.5] x = range(len(bodies)) plt.bar(x, v1, width=0.4, label=\"1st Cosmic Velocity\", align='center') plt.bar([i + 0.4 for i in x], v2, width=0.4, label=\"2nd Cosmic Velocity\", align='center') plt.xticks([i + 0.2 for i in x], bodies) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Comparison of Cosmic Velocities\") plt.legend() plt.grid(axis='y') plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#i-why-the-motivation-and-why-cosmic-velocities-matter-sections-are-important","text":"","title":"\u2139\ufe0f Why the \"Motivation\" and \"Why Cosmic Velocities Matter\" Sections are Important"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"","title":"\ud83d\udcd8 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#what-is-it","text":"This section explains why the topic is important , why it matters, and where it is applied.","title":"\ud83d\udd39 What is it?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#why-is-it-needed","text":"Helps the reader get into the topic . Explains why cosmic velocities are important to study . Makes the project more meaningful and complete . Answers the question: \"Why should I care about this?\"","title":"\ud83d\udd39 Why is it needed?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#alternative","text":"If you want, you can replace it with a short introduction like: This work discusses the speeds needed to reach orbit, escape a planet's gravity, and leave the solar system.","title":"\ud83d\udd39 Alternative"},{"location":"1%20Physics/2%20Gravity/Problem_2/#why-cosmic-velocities-matter","text":"","title":"\u2753 Why Cosmic Velocities Matter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#what-is-it_1","text":"This concluding section shows the practical value of the entire work.","title":"\ud83d\udd39 What is it?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#why-is-it-needed_1","text":"Connects formulas and calculations with real-life applications . Shows where they are used: First cosmic velocity \u2014 for satellites and orbits. Second cosmic velocity \u2014 for missions to the Moon and Mars. Third cosmic velocity \u2014 for missions beyond the solar system (e.g., Voyager).","title":"\ud83d\udd39 Why is it needed?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#benefits-for-the-project","text":"Helps understand the meaning behind the calculations . Makes the report complete and logical . Creates a better impression during the defense .","title":"\ud83d\udd39 Benefits for the project"},{"location":"1%20Physics/2%20Gravity/Problem_2/#how-to-simplify-it","text":"These velocities are important for space exploration because they help us understand the speeds required to launch satellites, send rockets to other planets, or even beyond the solar system. \u2705 These sections make your work not just \"formula-based\" but meaningful and engaging .","title":"\ud83d\udd39 How to simplify it"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-and-escape-velocities","text":"","title":"\ud83d\ude80 Cosmic Velocities and Escape Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#what-are-cosmic-velocities","text":"Cosmic velocities are speeds needed to move around or escape a celestial body: First Cosmic Velocity (v\u2081) : To orbit the body in a circle (like satellites). Second Cosmic Velocity (v\u2082) : To escape its gravity (like flying to space). Third Cosmic Velocity (v\u2083) : To leave the Solar System.","title":"\ud83d\udcd8 What Are Cosmic Velocities?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations","text":"","title":"\ud83e\udde0 Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"Meaning : Minimum speed to orbit just above the surface.","title":"1\ufe0f\u20e3 First Cosmic Velocity \\( v_1 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation","text":"Centripetal force: $$ F = \\frac{m \\cdot v^2}{r} $$ Gravitational force: $$ F = \\frac{G \\cdot M \\cdot m}{r^2} $$ Equating: \\[ \\frac{m \\cdot v^2}{r} = \\frac{G \\cdot M \\cdot m}{r^2} \\] Cancelling \\( m \\) and solving: \\[ v_1 = \\sqrt{\\frac{G \\cdot M}{r}} \\]","title":"Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2","text":"Meaning : Minimum speed to escape a planet's gravity.","title":"2\ufe0f\u20e3 Second Cosmic Velocity \\( v_2 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation_1","text":"From energy conservation: \\[ \\frac{1}{2}mv^2 - \\frac{G M m}{r} = 0 \\] Solving: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} = \\sqrt{2} \\cdot v_1 \\]","title":"Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3","text":"Meaning : Speed to escape the Sun starting from Earth\u2019s orbit.","title":"3\ufe0f\u20e3 Third Cosmic Velocity \\( v_3 \\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#formula","text":"\\[ v_3 = \\sqrt{\\frac{2 G M_{sun}}{r_{orbit}}} \\]","title":"Formula:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth-example-values","text":"\\($ G = 6.674 \\cdot 10^{-11} \\, \\text{m}^3/\\text{kg s}^2 $\\) \\($ M = 5.972 \\cdot 10^{24} \\, \\text{kg} $\\) \\($ r = 6.371 \\cdot 10^6 \\, \\text{m} $\\) \\($ M_{sun} = 1.989 \\cdot 10^{30} \\, \\text{kg}$ \\) \\($ r_{earth\\ orbit} = 1.496 \\cdot 10^{11} \\, \\text{m} $\\)","title":"\ud83c\udf0d Earth: Example Values"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculated","text":"\\($ v_1 \\approx 7.9 \\, \\text{km/s} $\\) \\($ v_2 \\approx 11.2 \\, \\text{km/s} $\\) \\($ v_3 \\approx 42.1 \\, \\text{km/s} $\\)","title":"Calculated:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-table","text":"Celestial Body Mass (kg) Radius (m) \\( v_1 \\) (km/s) \\( v_2 \\) (km/s) Moon \\($7.35 \\cdot 10^{22}$\\) \\($1.74 \\cdot 10^6$\\) 1.68 2.38 Earth \\($5.97 \\cdot 10^{24}$\\) \\($6.37 \\cdot 10^6$\\) 7.9 11.2 Mars \\($6.42 \\cdot 10^{23}$\\) \\($3.39 \\cdot 10^6$\\) 3.6 5.0 Jupiter \\($1.90 \\cdot 10^{27}$\\) \\($6.99 \\cdot 10^7$\\) 42.1 59.5","title":"\ud83c\udf0c Comparison Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization-python","text":"Visit My Collab import matplotlib.pyplot as plt bodies = [\"Moon\", \"Earth\", \"Mars\", \"Jupiter\"] v1 = [1.68, 7.9, 3.6, 42.1] v2 = [2.38, 11.2, 5.0, 59.5] x = range(len(bodies)) plt.bar(x, v1, width=0.4, label=\"1st Cosmic Velocity\", align='center') plt.bar([i + 0.4 for i in x], v2, width=0.4, label=\"2nd Cosmic Velocity\", align='center') plt.xticks([i + 0.2 for i in x], bodies) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Comparison of Cosmic Velocities\") plt.legend() plt.grid(axis='y') plt.show()","title":"\ud83d\udcca Visualization (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf0d Trajectories of a Freely Released Payload Near Earth \ud83d\udccc Motivation When a spacecraft releases a payload near Earth, the path it follows depends on: Its initial position and speed The direction of motion The gravitational pull of Earth Understanding these paths helps in planning: Satellite orbits Reentry to Earth Escaping Earth's gravity for deep space travel \ud83e\udde0 Key Concepts 1. Newton's Law of Universal Gravitation Every object attracts every other object with a force: \\[ F = \\frac{G \\cdot M \\cdot m}{r^2} \\] Where: \\( F \\) is the gravitational force \\( G \\) is the gravitational constant \\( M \\) is the mass of Earth \\( m \\) is the mass of the payload \\( r \\) is the distance from the center of Earth This force always pulls toward the center of Earth. 2. Kinetic and Potential Energy A payload has two key types of energy: Kinetic Energy (moving): [ $ KE = \\frac{1}{2}mv^2 $ ] Gravitational Potential Energy : [ $ PE = -\\frac{G M m}{r} $ ] The total energy determines the shape of the trajectory. \ud83d\ude80 Types of Trajectories \ud83c\udf10 Circular Orbit Speed is just right to balance gravity Path is a circle Total energy is constant and negative \ud83d\udd01 Elliptical Orbit Speed is not perfectly balanced Payload moves closer and farther from Earth Total energy is still negative \ud83e\ude83 Parabolic Trajectory Speed is just enough to escape Earth Total energy is zero It\u2019s a boundary between orbit and escape \ud83d\udeeb Hyperbolic Trajectory Speed is greater than needed to escape Payload leaves Earth forever Total energy is positive \ud83e\uddee Escape Velocity The speed needed to leave Earth without falling back: \\[ $ v_{escape} = \\sqrt{\\frac{2GM}{r}} $ \\] At sea level: \\[ $ v_{escape} \\approx 11.2 \\text{ km/s} $ \\] \ud83d\udd22 Numerical Simulation (Concept) To simulate motion step-by-step: Set the initial position and velocity of the payload. At each time step: Compute the gravitational force: [ $ F = \\frac{G M m}{r^2} $ ] Calculate acceleration: [ $ a = \\frac{F}{m} $ ] Update velocity: [ $ v_{new} = v + a \\cdot \\Delta t $ ] Update position: [ $ r_{new} = r + v \\cdot \\Delta t $ ] Repeat to track the trajectory shape (circular, elliptical, parabolic, hyperbolic) \ud83d\udcca Visualization Goals A plot of Earth and the payload path Comparison of multiple initial speeds Labels for escape , reentry , and orbit scenarios \ud83c\udf0c Real-World Applications Satellites must be released into elliptical or circular orbits Spacecraft aiming for other planets use hyperbolic trajectories Reentry capsules follow elliptical or parabolic paths \u2705 Summary Condition Trajectory Type Total Energy Low speed Elliptical orbit Negative Just right speed Circular orbit Negative Exactly escape speed Parabolic path Zero Greater than escape speed Hyperbolic path Positive Problem 3: Motion of a Body in Earth's Gravitational Field Problem statement: - Create a plot with the Earth drawn to scale. - Initial position: 800 km above Earth's surface (placed on the right-hand side of the plot). - Launch a body with various initial speeds: 5 km/s, 5.5 km/s, ..., up to 13 km/s. - Only gravitational interaction is considered. Model: - Earth's radius: 6371 km. - Gravitational acceleration calculated using Newton\u2019s law of universal gravitation. - Two-dimensional plane, launch point at (R_Earth + 800 km, 0). - Each trajectory shows motion of the body for a given initial velocity. Result: Visit My Collab import numpy as np import matplotlib.pyplot as plt # \u0413\u0440\u0430\u0432\u0438\u0442\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b G = 6.67430e-11 # \u043c^3 \u043a\u0433^-1 \u0441^-2 M = 5.972e24 # \u043c\u0430\u0441\u0441\u0430 \u0417\u0435\u043c\u043b\u0438, \u043a\u0433 R_earth = 6.371e6 # \u0440\u0430\u0434\u0438\u0443\u0441 \u0417\u0435\u043c\u043b\u0438, \u043c # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f altitude = 800e3 # 800 \u043a\u043c \u043d\u0430\u0434 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e r0 = np.array([R_earth + altitude, 0]) # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u043f\u0440\u0430\u0432\u0430 \u043e\u0442 \u0417\u0435\u043c\u043b\u0438 velocities = np.arange(5e3, 13.5e3, 0.5e3) # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u043e\u0442 5 \u0434\u043e 13 \u043a\u043c/\u0441 # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b dt = 1 # \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0441) T = 10000 # \u043e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f (\u0441) steps = int(T / dt) # \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 fig, ax = plt.subplots(figsize=(8, 8)) theta = np.linspace(0, 2 * np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, 'b', label='\u0417\u0435\u043c\u043b\u044f', alpha=0.5) # \u0421\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u044f \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 colors = plt.cm.viridis(np.linspace(0, 1, len(velocities))) for v0, color in zip(velocities, colors): r = r0.copy() v = np.array([0, v0]) traj_x, traj_y = [], [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: # \u0435\u0441\u043b\u0438 \u0433\u0440\u0443\u0437 \u0432\u0440\u0435\u0437\u0430\u043b\u0441\u044f \u0432 \u0417\u0435\u043c\u043b\u044e break a = -G * M * r / r_mag**3 v += a * dt r += v * dt traj_x.append(r[0]) traj_y.append(r[1]) ax.plot(traj_x, traj_y, label=f'{v0/1000:.1f} \u043a\u043c/\u0441', color=color) # \u041e\u0444\u043e\u0440\u043c\u043b\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 ax.set_aspect('equal') ax.set_xlim(-2e7, 2e7) ax.set_ylim(-2e7, 2e7) ax.set_xlabel('x (\u043c)') ax.set_ylabel('y (\u043c)') ax.set_title('\u0422\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u0433\u0440\u0443\u0437\u0430 \u043f\u0440\u0438 \u0441\u0431\u0440\u043e\u0441\u0435 \u0441 \u0432\u044b\u0441\u043e\u0442\u044b 800 \u043a\u043c') ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show() The blue circle represents Earth. Each curve shows the trajectory for a specific launch speed (from 5 to 13 km/s). We can observe which speeds lead to orbits, collisions with Earth, or escape into space. \ud83d\udcda Kepler's Law. Finding the Mass of Earth and the Mass of the Sun # --- Imports --- import numpy as np import matplotlib.pyplot as plt # --- Physical Constants --- G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 AU = 1.496e11 # 1 astronomical unit (average Earth-Sun distance), m day = 24 * 3600 # seconds in one day year = 365.25 * day # seconds in one year # --- Kepler's Third Law Formula --- # T^2 = (4\u03c0\u00b2/GM) * R\u00b3 # => M = (4\u03c0\u00b2 R\u00b3) / (G T\u00b2) def mass_from_orbit(R, T): return (4 * np.pi**2 * R**3) / (G * T**2) # --- 1. Finding the Mass of the Sun from Earth's Orbit --- R_earth_orbit = AU # Earth's orbit radius (m) T_earth_orbit = year # Earth's orbital period (s) M_sun = mass_from_orbit(R_earth_orbit, T_earth_orbit) print(f\"\u2600\ufe0f Mass of the Sun \u2248 {M_sun:.2e} kg\") # --- 2. Finding the Mass of the Earth from the Moon's Orbit --- # Parameters of the Moon's orbit: R_moon_orbit = 384400e3 # average distance to the Moon (m) T_moon_orbit = 27.32 * day # Moon's orbital period (s) M_earth = mass_from_orbit(R_moon_orbit, T_moon_orbit) print(f\"\ud83c\udf0d Mass of the Earth \u2248 {M_earth:.2e} kg\") # --- 3. Plotting T\u00b2 vs R\u00b3 --- # Example planetary data (Solar System planets) radii = np.array([ 57.9e9, # Mercury 108.2e9, # Venus 149.6e9, # Earth 227.9e9, # Mars 778.5e9, # Jupiter 1433e9, # Saturn 2877e9, # Uranus 4503e9 # Neptune ]) periods_days = np.array([ 88, # Mercury 224.7, # Venus 365.25, # Earth 687, # Mars 4331, # Jupiter 10747, # Saturn 30589, # Uranus 59800 # Neptune ]) # Convert to seconds periods_seconds = periods_days * day # Calculate T\u00b2 and R\u00b3 T_squared = periods_seconds**2 R_cubed = radii**3 # --- Plot T\u00b2 vs R\u00b3 --- plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, 'o-', label=\"Planets\") plt.xlabel('$R^3$ (m\u00b3)', fontsize=12) plt.ylabel('$T^2$ (s\u00b2)', fontsize=12) plt.title('Dependence of $T^2$ on $R^3$ (Kepler\\'s Third Law)', fontsize=14) plt.grid(True) plt.legend() plt.show() # --- 4. Checking the linear relation (log-log plot) --- plt.figure(figsize=(8,6)) plt.plot(np.log10(R_cubed), np.log10(T_squared), 'o-', label=\"Planets\") plt.xlabel('log($R^3$)', fontsize=12) plt.ylabel('log($T^2$)', fontsize=12) plt.title('Log-Log Plot: $T^2$ vs $R^3$', fontsize=14) plt.grid(True) plt.legend() plt.show() \ud83d\udcca What This Code Does: Calculates the mass of the Sun using Earth's orbit. Calculates the mass of the Earth using the Moon's orbit. Plots the \\(T^2\\) versus \\(R^3\\) relation for Solar System planets to verify Kepler\u2019s Third Law. Plots a log-log graph to confirm the linear relationship. \ud83d\udcc8 Final Results: Mass of the Sun \u2248 1.99 \u00d7 10\u00b3\u2070 kg Mass of the Earth \u2248 5.97 \u00d7 10\u00b2\u2074 kg (which perfectly matches known scientific values \u2705)","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"\ud83c\udf0d Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a spacecraft releases a payload near Earth, the path it follows depends on: Its initial position and speed The direction of motion The gravitational pull of Earth Understanding these paths helps in planning: Satellite orbits Reentry to Earth Escaping Earth's gravity for deep space travel","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-concepts","text":"","title":"\ud83e\udde0 Key Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-newtons-law-of-universal-gravitation","text":"Every object attracts every other object with a force: \\[ F = \\frac{G \\cdot M \\cdot m}{r^2} \\] Where: \\( F \\) is the gravitational force \\( G \\) is the gravitational constant \\( M \\) is the mass of Earth \\( m \\) is the mass of the payload \\( r \\) is the distance from the center of Earth This force always pulls toward the center of Earth.","title":"1. Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-kinetic-and-potential-energy","text":"A payload has two key types of energy: Kinetic Energy (moving): [ $ KE = \\frac{1}{2}mv^2 $ ] Gravitational Potential Energy : [ $ PE = -\\frac{G M m}{r} $ ] The total energy determines the shape of the trajectory.","title":"2. Kinetic and Potential Energy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"","title":"\ud83d\ude80 Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#circular-orbit","text":"Speed is just right to balance gravity Path is a circle Total energy is constant and negative","title":"\ud83c\udf10 Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#elliptical-orbit","text":"Speed is not perfectly balanced Payload moves closer and farther from Earth Total energy is still negative","title":"\ud83d\udd01 Elliptical Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_3/#parabolic-trajectory","text":"Speed is just enough to escape Earth Total energy is zero It\u2019s a boundary between orbit and escape","title":"\ud83e\ude83 Parabolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#hyperbolic-trajectory","text":"Speed is greater than needed to escape Payload leaves Earth forever Total energy is positive","title":"\ud83d\udeeb Hyperbolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The speed needed to leave Earth without falling back: \\[ $ v_{escape} = \\sqrt{\\frac{2GM}{r}} $ \\] At sea level: \\[ $ v_{escape} \\approx 11.2 \\text{ km/s} $ \\]","title":"\ud83e\uddee Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-concept","text":"To simulate motion step-by-step: Set the initial position and velocity of the payload. At each time step: Compute the gravitational force: [ $ F = \\frac{G M m}{r^2} $ ] Calculate acceleration: [ $ a = \\frac{F}{m} $ ] Update velocity: [ $ v_{new} = v + a \\cdot \\Delta t $ ] Update position: [ $ r_{new} = r + v \\cdot \\Delta t $ ] Repeat to track the trajectory shape (circular, elliptical, parabolic, hyperbolic)","title":"\ud83d\udd22 Numerical Simulation (Concept)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization-goals","text":"A plot of Earth and the payload path Comparison of multiple initial speeds Labels for escape , reentry , and orbit scenarios","title":"\ud83d\udcca Visualization Goals"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellites must be released into elliptical or circular orbits Spacecraft aiming for other planets use hyperbolic trajectories Reentry capsules follow elliptical or parabolic paths","title":"\ud83c\udf0c Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"Condition Trajectory Type Total Energy Low speed Elliptical orbit Negative Just right speed Circular orbit Negative Exactly escape speed Parabolic path Zero Greater than escape speed Hyperbolic path Positive","title":"\u2705 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-motion-of-a-body-in-earths-gravitational-field","text":"Problem statement: - Create a plot with the Earth drawn to scale. - Initial position: 800 km above Earth's surface (placed on the right-hand side of the plot). - Launch a body with various initial speeds: 5 km/s, 5.5 km/s, ..., up to 13 km/s. - Only gravitational interaction is considered. Model: - Earth's radius: 6371 km. - Gravitational acceleration calculated using Newton\u2019s law of universal gravitation. - Two-dimensional plane, launch point at (R_Earth + 800 km, 0). - Each trajectory shows motion of the body for a given initial velocity. Result: Visit My Collab import numpy as np import matplotlib.pyplot as plt # \u0413\u0440\u0430\u0432\u0438\u0442\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b G = 6.67430e-11 # \u043c^3 \u043a\u0433^-1 \u0441^-2 M = 5.972e24 # \u043c\u0430\u0441\u0441\u0430 \u0417\u0435\u043c\u043b\u0438, \u043a\u0433 R_earth = 6.371e6 # \u0440\u0430\u0434\u0438\u0443\u0441 \u0417\u0435\u043c\u043b\u0438, \u043c # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f altitude = 800e3 # 800 \u043a\u043c \u043d\u0430\u0434 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e r0 = np.array([R_earth + altitude, 0]) # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u043f\u0440\u0430\u0432\u0430 \u043e\u0442 \u0417\u0435\u043c\u043b\u0438 velocities = np.arange(5e3, 13.5e3, 0.5e3) # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u043e\u0442 5 \u0434\u043e 13 \u043a\u043c/\u0441 # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b dt = 1 # \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0441) T = 10000 # \u043e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f (\u0441) steps = int(T / dt) # \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 fig, ax = plt.subplots(figsize=(8, 8)) theta = np.linspace(0, 2 * np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, 'b', label='\u0417\u0435\u043c\u043b\u044f', alpha=0.5) # \u0421\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u044f \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 colors = plt.cm.viridis(np.linspace(0, 1, len(velocities))) for v0, color in zip(velocities, colors): r = r0.copy() v = np.array([0, v0]) traj_x, traj_y = [], [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: # \u0435\u0441\u043b\u0438 \u0433\u0440\u0443\u0437 \u0432\u0440\u0435\u0437\u0430\u043b\u0441\u044f \u0432 \u0417\u0435\u043c\u043b\u044e break a = -G * M * r / r_mag**3 v += a * dt r += v * dt traj_x.append(r[0]) traj_y.append(r[1]) ax.plot(traj_x, traj_y, label=f'{v0/1000:.1f} \u043a\u043c/\u0441', color=color) # \u041e\u0444\u043e\u0440\u043c\u043b\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 ax.set_aspect('equal') ax.set_xlim(-2e7, 2e7) ax.set_ylim(-2e7, 2e7) ax.set_xlabel('x (\u043c)') ax.set_ylabel('y (\u043c)') ax.set_title('\u0422\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u0433\u0440\u0443\u0437\u0430 \u043f\u0440\u0438 \u0441\u0431\u0440\u043e\u0441\u0435 \u0441 \u0432\u044b\u0441\u043e\u0442\u044b 800 \u043a\u043c') ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show() The blue circle represents Earth. Each curve shows the trajectory for a specific launch speed (from 5 to 13 km/s). We can observe which speeds lead to orbits, collisions with Earth, or escape into space. \ud83d\udcda Kepler's Law. Finding the Mass of Earth and the Mass of the Sun # --- Imports --- import numpy as np import matplotlib.pyplot as plt # --- Physical Constants --- G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 AU = 1.496e11 # 1 astronomical unit (average Earth-Sun distance), m day = 24 * 3600 # seconds in one day year = 365.25 * day # seconds in one year # --- Kepler's Third Law Formula --- # T^2 = (4\u03c0\u00b2/GM) * R\u00b3 # => M = (4\u03c0\u00b2 R\u00b3) / (G T\u00b2) def mass_from_orbit(R, T): return (4 * np.pi**2 * R**3) / (G * T**2) # --- 1. Finding the Mass of the Sun from Earth's Orbit --- R_earth_orbit = AU # Earth's orbit radius (m) T_earth_orbit = year # Earth's orbital period (s) M_sun = mass_from_orbit(R_earth_orbit, T_earth_orbit) print(f\"\u2600\ufe0f Mass of the Sun \u2248 {M_sun:.2e} kg\") # --- 2. Finding the Mass of the Earth from the Moon's Orbit --- # Parameters of the Moon's orbit: R_moon_orbit = 384400e3 # average distance to the Moon (m) T_moon_orbit = 27.32 * day # Moon's orbital period (s) M_earth = mass_from_orbit(R_moon_orbit, T_moon_orbit) print(f\"\ud83c\udf0d Mass of the Earth \u2248 {M_earth:.2e} kg\") # --- 3. Plotting T\u00b2 vs R\u00b3 --- # Example planetary data (Solar System planets) radii = np.array([ 57.9e9, # Mercury 108.2e9, # Venus 149.6e9, # Earth 227.9e9, # Mars 778.5e9, # Jupiter 1433e9, # Saturn 2877e9, # Uranus 4503e9 # Neptune ]) periods_days = np.array([ 88, # Mercury 224.7, # Venus 365.25, # Earth 687, # Mars 4331, # Jupiter 10747, # Saturn 30589, # Uranus 59800 # Neptune ]) # Convert to seconds periods_seconds = periods_days * day # Calculate T\u00b2 and R\u00b3 T_squared = periods_seconds**2 R_cubed = radii**3 # --- Plot T\u00b2 vs R\u00b3 --- plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, 'o-', label=\"Planets\") plt.xlabel('$R^3$ (m\u00b3)', fontsize=12) plt.ylabel('$T^2$ (s\u00b2)', fontsize=12) plt.title('Dependence of $T^2$ on $R^3$ (Kepler\\'s Third Law)', fontsize=14) plt.grid(True) plt.legend() plt.show() # --- 4. Checking the linear relation (log-log plot) --- plt.figure(figsize=(8,6)) plt.plot(np.log10(R_cubed), np.log10(T_squared), 'o-', label=\"Planets\") plt.xlabel('log($R^3$)', fontsize=12) plt.ylabel('log($T^2$)', fontsize=12) plt.title('Log-Log Plot: $T^2$ vs $R^3$', fontsize=14) plt.grid(True) plt.legend() plt.show() \ud83d\udcca What This Code Does: Calculates the mass of the Sun using Earth's orbit. Calculates the mass of the Earth using the Moon's orbit. Plots the \\(T^2\\) versus \\(R^3\\) relation for Solar System planets to verify Kepler\u2019s Third Law. Plots a log-log graph to confirm the linear relationship. \ud83d\udcc8 Final Results: Mass of the Sun \u2248 1.99 \u00d7 10\u00b3\u2070 kg Mass of the Earth \u2248 5.97 \u00d7 10\u00b2\u2074 kg (which perfectly matches known scientific values \u2705)","title":"Problem 3: Motion of a Body in Earth's Gravitational Field"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Problem: Interference of Waves from Multiple Sources Problem statement: - Demonstrate wave interference for one, two, and multiple sources. - Display the result as a heatmap and create an animation. - Source arrangements: - One centered source, - Two along the X-axis, - Three placed in a triangle. - Plot the results and create a gif animation. Method: - Wave equation used: z(x, y, t) = A * sin(k * r - \u03c9 * t) - The contribution from each source is summed. - Grid from -10 to 10 in both x and y. - Animation shows wave propagation and interference over time. Result (animation): import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # --- Grid Setup --- size = 200 x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Wave Function --- def wave_source(X, Y, x0, y0, t, wavelength=1, speed=1): r = np.sqrt((X - x0)**2 + (Y - y0)**2) k = 2 * np.pi / wavelength omega = k * speed return np.sin(k * r - omega * t) / (r + 1e-6) # avoid division by zero # --- Source Patterns --- def get_sources(pattern): if pattern == \"one\": return [(0, 0)] elif pattern == \"two\": return [(-3, 0), (3, 0)] elif pattern == \"triangle\": R = 4 angles = np.linspace(0, 2*np.pi, 4)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] elif pattern == \"pentagon\": R = 5 angles = np.linspace(0, 2*np.pi, 6)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] patterns = [\"one\", \"two\", \"triangle\", \"pentagon\"] # --- Plot Setup --- fig, ax = plt.subplots(figsize=(6,6)) heatmap = ax.imshow(np.zeros((size, size)), cmap='RdBu', vmin=-1, vmax=1, extent=(-10, 10, -10, 10)) title = ax.set_title(\"\") # --- Frame Update Function --- def update(frame): pattern = patterns[(frame // 20) % len(patterns)] t = frame % 20 sources = get_sources(pattern) Z = sum(wave_source(X, Y, sx, sy, t) for sx, sy in sources) heatmap.set_data(Z) title.set_text(f\"Wave Interference: {pattern.capitalize()} ({len(sources)} source{'s' if len(sources) > 1 else ''})\") return heatmap, title # --- Create Animation --- ani = animation.FuncAnimation(fig, update, frames=80, interval=100, blit=False) # --- Save GIF --- ani.save(\"wave_interference.gif\", writer=\"pillow\") plt.close() print(\"\u2705 GIF saved as wave_interference.gif\") import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from mpl_toolkits.mplot3d import Axes3D # --- Grid Setup --- size = 100 # smaller size for faster rendering x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Wave Function --- def wave_source(X, Y, x0, y0, t, wavelength=1, speed=1): r = np.sqrt((X - x0)**2 + (Y - y0)**2) k = 2 * np.pi / wavelength omega = k * speed return np.sin(k * r - omega * t) / (r + 1e-6) # --- Source Patterns --- def get_sources(pattern): if pattern == \"one\": return [(0, 0)] elif pattern == \"two\": return [(-3, 0), (3, 0)] elif pattern == \"triangle\": R = 4 angles = np.linspace(0, 2*np.pi, 4)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] elif pattern == \"pentagon\": R = 5 angles = np.linspace(0, 2*np.pi, 6)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] patterns = [\"one\", \"two\", \"triangle\", \"pentagon\"] # --- Plot Setup --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') Z = np.zeros_like(X) surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') title = ax.set_title(\"\") # --- Frame Update Function --- def update(frame): pattern = patterns[(frame // 20) % len(patterns)] t = frame % 20 sources = get_sources(pattern) Z = sum(wave_source(X, Y, sx, sy, t) for sx, sy in sources) ax.clear() # careful: only light clearing surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') ax.set_title(f\"Wave Interference: {pattern.capitalize()} ({len(sources)} source{'s' if len(sources) > 1 else ''})\") return surf, # --- Create Animation --- ani = animation.FuncAnimation(fig, update, frames=80, interval=100, blit=False) # --- Save Animation --- ani.save('/content/wave_interference_3d.gif', writer='pillow') plt.close() print(\"\u2705 3D GIF saved as /content/wave_interference_3d.gif\") Left plot: one source \u2014 circular wavefronts. Middle plot: two sources \u2014 clear interference pattern. Right plot: three sources in a triangle \u2014 complex interference structure. Conclusion: - Orbital trajectories depend critically on initial velocity. - Wave interference clearly demonstrates the principle of superposition: the combination of phase and amplitude when multiple waves interact.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-problem-interference-of-waves-from-multiple-sources","text":"Problem statement: - Demonstrate wave interference for one, two, and multiple sources. - Display the result as a heatmap and create an animation. - Source arrangements: - One centered source, - Two along the X-axis, - Three placed in a triangle. - Plot the results and create a gif animation. Method: - Wave equation used: z(x, y, t) = A * sin(k * r - \u03c9 * t) - The contribution from each source is summed. - Grid from -10 to 10 in both x and y. - Animation shows wave propagation and interference over time. Result (animation): import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # --- Grid Setup --- size = 200 x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Wave Function --- def wave_source(X, Y, x0, y0, t, wavelength=1, speed=1): r = np.sqrt((X - x0)**2 + (Y - y0)**2) k = 2 * np.pi / wavelength omega = k * speed return np.sin(k * r - omega * t) / (r + 1e-6) # avoid division by zero # --- Source Patterns --- def get_sources(pattern): if pattern == \"one\": return [(0, 0)] elif pattern == \"two\": return [(-3, 0), (3, 0)] elif pattern == \"triangle\": R = 4 angles = np.linspace(0, 2*np.pi, 4)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] elif pattern == \"pentagon\": R = 5 angles = np.linspace(0, 2*np.pi, 6)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] patterns = [\"one\", \"two\", \"triangle\", \"pentagon\"] # --- Plot Setup --- fig, ax = plt.subplots(figsize=(6,6)) heatmap = ax.imshow(np.zeros((size, size)), cmap='RdBu', vmin=-1, vmax=1, extent=(-10, 10, -10, 10)) title = ax.set_title(\"\") # --- Frame Update Function --- def update(frame): pattern = patterns[(frame // 20) % len(patterns)] t = frame % 20 sources = get_sources(pattern) Z = sum(wave_source(X, Y, sx, sy, t) for sx, sy in sources) heatmap.set_data(Z) title.set_text(f\"Wave Interference: {pattern.capitalize()} ({len(sources)} source{'s' if len(sources) > 1 else ''})\") return heatmap, title # --- Create Animation --- ani = animation.FuncAnimation(fig, update, frames=80, interval=100, blit=False) # --- Save GIF --- ani.save(\"wave_interference.gif\", writer=\"pillow\") plt.close() print(\"\u2705 GIF saved as wave_interference.gif\") import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from mpl_toolkits.mplot3d import Axes3D # --- Grid Setup --- size = 100 # smaller size for faster rendering x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Wave Function --- def wave_source(X, Y, x0, y0, t, wavelength=1, speed=1): r = np.sqrt((X - x0)**2 + (Y - y0)**2) k = 2 * np.pi / wavelength omega = k * speed return np.sin(k * r - omega * t) / (r + 1e-6) # --- Source Patterns --- def get_sources(pattern): if pattern == \"one\": return [(0, 0)] elif pattern == \"two\": return [(-3, 0), (3, 0)] elif pattern == \"triangle\": R = 4 angles = np.linspace(0, 2*np.pi, 4)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] elif pattern == \"pentagon\": R = 5 angles = np.linspace(0, 2*np.pi, 6)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] patterns = [\"one\", \"two\", \"triangle\", \"pentagon\"] # --- Plot Setup --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') Z = np.zeros_like(X) surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') title = ax.set_title(\"\") # --- Frame Update Function --- def update(frame): pattern = patterns[(frame // 20) % len(patterns)] t = frame % 20 sources = get_sources(pattern) Z = sum(wave_source(X, Y, sx, sy, t) for sx, sy in sources) ax.clear() # careful: only light clearing surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') ax.set_title(f\"Wave Interference: {pattern.capitalize()} ({len(sources)} source{'s' if len(sources) > 1 else ''})\") return surf, # --- Create Animation --- ani = animation.FuncAnimation(fig, update, frames=80, interval=100, blit=False) # --- Save Animation --- ani.save('/content/wave_interference_3d.gif', writer='pillow') plt.close() print(\"\u2705 3D GIF saved as /content/wave_interference_3d.gif\") Left plot: one source \u2014 circular wavefronts. Middle plot: two sources \u2014 clear interference pattern. Right plot: three sources in a triangle \u2014 complex interference structure. Conclusion: - Orbital trajectories depend critically on initial velocity. - Wave interference clearly demonstrates the principle of superposition: the combination of phase and amplitude when multiple waves interact.","title":"Wave Problem: Interference of Waves from Multiple Sources"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism Problem 1 \u2014 Simulation of the Lorentz Force \ud83c\udf1f Motivation The Lorentz force governs how a charged particle moves through electric and magnetic fields . Understanding this phenomenon is essential in a wide range of scientific and engineering applications: \u269b Particle Accelerators \u2014 Guide and speed up particles using magnetic fields. \ud83e\uddea Mass Spectrometry \u2014 Identify chemical substances by separating ions by mass and charge. \ud83d\udd25 Plasma Confinement \u2014 Trap hot plasma in devices for nuclear fusion (e.g., Tokamaks). \ud83c\udf0c Space Physics \u2014 Explain how charged particles (like solar wind) interact with magnetic fields in space. The Lorentz force is described by the equation: \ud835\udc05 = q(\ud835\udc04 + \ud835\udc2f \u00d7 \ud835\udc01) Where: - \ud835\udc05 \u2014 Lorentz force - q \u2014 Particle charge - \ud835\udc04 \u2014 Electric field vector - \ud835\udc2f \u2014 Particle velocity - \ud835\udc01 \u2014 Magnetic field vector - \u00d7 \u2014 Cross product \u2699\ufe0f 1. Applications of the Lorentz Force \ud83e\udded Real-World Examples: Cyclotrons use magnetic fields to spiral particles at high speeds. Mass spectrometers rely on Lorentz force to sort ions. Fusion reactors contain plasma using powerful magnetic traps. Satellites and space probes analyze particle motion in Earth\u2019s magnetosphere. \ud83d\udd0d Roles of Fields: Electric field (\ud835\udc04) accelerates or slows the particle. Magnetic field (\ud835\udc01) bends the trajectory, causing circular or spiral paths. \ud83e\uddee 2. Simulating Particle Motion We will explore different field configurations: Only Magnetic Field Parallel Electric and Magnetic Fields Perpendicular (Crossed) Fields To simulate motion, we\u2019ll use numerical methods like the Euler method to compute the particle\u2019s trajectory step by step. \ud83c\udf9b 3. Parameters to Explore To understand the system behavior, we\u2019ll vary the following: \ud83d\udd0c Electric Field Strength (\ud835\udc04) \ud83e\uddf2 Magnetic Field Strength (\ud835\udc01) \ud83d\ude80 Initial Velocity (\ud835\udc2f) \u26a1 Charge (q) \u2696\ufe0f Mass (m) These parameters affect: The radius of circular motion The drift speed of the particle in crossed fields The acceleration or deflection of the path \ud83d\udcc8 4. Visualization We'll build 2D and 3D plots of particle trajectories to visualize motion under various conditions. \u2728 Key Physical Quantities: Larmor Radius (circular orbit in magnetic field): [ r = \\(\\frac{m \\cdot v}{q \\cdot B}\\) ] Drift Velocity in crossed electric and magnetic fields: [ \\(\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) ] These plots will illustrate how particles spiral, drift, and accelerate depending on the field setup. \ud83e\uddea Discussion of Results \ud83d\udd04 Trajectory Shape The particle moves in a circular path within a plane perpendicular to the magnetic field. This is characteristic motion observed in devices like cyclotrons and mass spectrometers . \u26a1 No Electric Field We set the electric field to \ud835\udc04 = 0 , so there is no acceleration along the field direction \u2014 the particle only rotates in response to the magnetic field. \ud83e\udde0 Physical Interpretation The radius of the circular trajectory depends on the particle's: velocity (v) mass (m) charge (q) magnetic field strength (B) It is given by the formula: \\[ $ r = \\frac{m \\cdot v}{q \\cdot B} $ \\] This type of motion is utilized in a cyclotron , where the magnetic field bends the trajectory into a spiral, allowing for gradual acceleration of particles. Visit My Collab import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 q = 1.0 # \u0437\u0430\u0440\u044f\u0434 (\u041a\u043b) m = 1.0 # \u043c\u0430\u0441\u0441\u0430 (\u043a\u0433) v0 = np.array([1.0, 0.0, 0.0]) # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c (\u043c/\u0441) E = np.array([0.0, 0.0, 0.0]) # \u044d\u043b\u0435\u043a\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0412/\u043c) B = np.array([0.0, 0.0, 1.0]) # \u043c\u0430\u0433\u043d\u0438\u0442\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0422\u043b) dt = 0.01 # \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0441) T = 20 # \u043e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0438 (\u0441) steps = int(T / dt) # \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432 r = np.zeros((steps, 3)) # \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b v = np.zeros((steps, 3)) # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 r[0] = [0.0, 0.0, 0.0] v[0] = v0 # \u041c\u0435\u0442\u043e\u0434 \u042d\u0439\u043b\u0435\u0440\u0430 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u0438 for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # --- \u0412\u0418\u0417\u0423\u0410\u041b\u0418\u0417\u0410\u0426\u0418\u042f --- # 2D \u0433\u0440\u0430\u0444\u0438\u043a plt.figure(figsize=(8, 6)) plt.plot(r[:, 0], r[:, 1]) plt.title(\"2D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0432 \u043c\u0430\u0433\u043d\u0438\u0442\u043d\u043e\u043c \u043f\u043e\u043b\u0435 (XY-\u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u044c)\") plt.xlabel(\"x (\u043c)\") plt.ylabel(\"y (\u043c)\") plt.grid(True) plt.axis(\"equal\") plt.show() # 3D \u0433\u0440\u0430\u0444\u0438\u043a fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2]) ax.set_title(\"3D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0447\u0430\u0441\u0442\u0438\u0446\u044b\") ax.set_xlabel(\"x (\u043c)\") ax.set_ylabel(\"y (\u043c)\") ax.set_zlabel(\"z (\u043c)\") plt.show() \ud83d\udd0d Analysis of Results \ud83c\udf00 Type of Motion The particle follows a drift trajectory , where circular motion is superimposed on a linear motion along the X-axis . This is a classic example of \ud835\udc04 \u00d7 \ud835\udc01 drift . \u2699\ufe0f Drift Velocity \u2014 Theoretical Calculation The drift velocity is given by: \\[ $\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $ \\] Given: - \ud835\udc04 = [0, 1, 0] - \ud835\udc01 = [0, 0, 1] Then: \\[ $ \\vec{v}_{\\text{drift}} = \\frac{[1, 0, 0]}{1^2} = [1, 0, 0] $ \\] \u2705 Result: The particle drifts along the X-axis with a constant velocity. \ud83e\udde9 Practical Significance This \ud835\udc04 \u00d7 \ud835\udc01 drift effect is widely used in: Plasma physics \u2014 to control plasma behavior in magnetic confinement systems Magnetic traps \u2014 for confining charged particles Beam control \u2014 in devices requiring precise particle guidance It is a key mechanism in systems such as fusion reactors , mass filters , and charged particle beams . Visit my collab import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b q = 1.6e-19 # \u0437\u0430\u0440\u044f\u0434 (\u041a\u043b) m = 9.1e-31 # \u043c\u0430\u0441\u0441\u0430 (\u043a\u0433) E = np.array([0, 1e3, 0]) # \u042d\u043b\u0435\u043a\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0412/\u043c) B = np.array([0, 0, 1]) # \u041c\u0430\u0433\u043d\u0438\u0442\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0422\u043b) v0 = np.cross(E, B) / np.linalg.norm(B)**2 # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0434\u0440\u0435\u0439\u0444\u0430 # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b t_max = 1e-7 dt = 1e-9 t = np.arange(0, t_max, dt) # \u041f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0447\u0430\u0441\u0442\u0438\u0446\u044b x = v0[0] * t y = v0[1] * t z = v0[2] * t # === \u041f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432 === fig = plt.figure(figsize=(10, 10)) # --- 2D \u0433\u0440\u0430\u0444\u0438\u043a --- ax1 = fig.add_subplot(2, 1, 1) ax1.plot(x, y, color='orange') ax1.set_title('2D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0432 \u043f\u0435\u0440\u0435\u043a\u0440\u0451\u0441\u0442\u043d\u044b\u0445 \u043f\u043e\u043b\u044f\u0445 (E \u22a5 B)', fontsize=14) ax1.set_xlabel('x (\u043c)') ax1.set_ylabel('y (\u043c)') ax1.grid(True) ax1.axis('equal') # --- 3D \u0433\u0440\u0430\u0444\u0438\u043a --- ax2 = fig.add_subplot(2, 1, 2, projection='3d') ax2.plot(x, y, z, color='orange') ax2.set_title('3D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0447\u0430\u0441\u0442\u0438\u0446\u044b \u0432 \u043f\u0435\u0440\u0435\u043a\u0440\u0451\u0441\u0442\u043d\u044b\u0445 \u043f\u043e\u043b\u044f\u0445', fontsize=14) ax2.set_xlabel('x (\u043c)') ax2.set_ylabel('y (\u043c)') ax2.set_zlabel('z (\u043c)') plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism","text":"","title":"Electromagnetism"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-simulation-of-the-lorentz-force","text":"","title":"Problem 1 \u2014 Simulation of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs how a charged particle moves through electric and magnetic fields . Understanding this phenomenon is essential in a wide range of scientific and engineering applications: \u269b Particle Accelerators \u2014 Guide and speed up particles using magnetic fields. \ud83e\uddea Mass Spectrometry \u2014 Identify chemical substances by separating ions by mass and charge. \ud83d\udd25 Plasma Confinement \u2014 Trap hot plasma in devices for nuclear fusion (e.g., Tokamaks). \ud83c\udf0c Space Physics \u2014 Explain how charged particles (like solar wind) interact with magnetic fields in space. The Lorentz force is described by the equation:","title":"\ud83c\udf1f Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#f-qe-v-b","text":"Where: - \ud835\udc05 \u2014 Lorentz force - q \u2014 Particle charge - \ud835\udc04 \u2014 Electric field vector - \ud835\udc2f \u2014 Particle velocity - \ud835\udc01 \u2014 Magnetic field vector - \u00d7 \u2014 Cross product","title":"\ud835\udc05 = q(\ud835\udc04 + \ud835\udc2f \u00d7 \ud835\udc01)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-applications-of-the-lorentz-force","text":"","title":"\u2699\ufe0f 1. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-examples","text":"Cyclotrons use magnetic fields to spiral particles at high speeds. Mass spectrometers rely on Lorentz force to sort ions. Fusion reactors contain plasma using powerful magnetic traps. Satellites and space probes analyze particle motion in Earth\u2019s magnetosphere.","title":"\ud83e\udded Real-World Examples:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#roles-of-fields","text":"Electric field (\ud835\udc04) accelerates or slows the particle. Magnetic field (\ud835\udc01) bends the trajectory, causing circular or spiral paths.","title":"\ud83d\udd0d Roles of Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We will explore different field configurations: Only Magnetic Field Parallel Electric and Magnetic Fields Perpendicular (Crossed) Fields To simulate motion, we\u2019ll use numerical methods like the Euler method to compute the particle\u2019s trajectory step by step.","title":"\ud83e\uddee 2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameters-to-explore","text":"To understand the system behavior, we\u2019ll vary the following: \ud83d\udd0c Electric Field Strength (\ud835\udc04) \ud83e\uddf2 Magnetic Field Strength (\ud835\udc01) \ud83d\ude80 Initial Velocity (\ud835\udc2f) \u26a1 Charge (q) \u2696\ufe0f Mass (m) These parameters affect: The radius of circular motion The drift speed of the particle in crossed fields The acceleration or deflection of the path","title":"\ud83c\udf9b 3. Parameters to Explore"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"We'll build 2D and 3D plots of particle trajectories to visualize motion under various conditions.","title":"\ud83d\udcc8 4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-physical-quantities","text":"Larmor Radius (circular orbit in magnetic field): [ r = \\(\\frac{m \\cdot v}{q \\cdot B}\\) ] Drift Velocity in crossed electric and magnetic fields: [ \\(\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) ] These plots will illustrate how particles spiral, drift, and accelerate depending on the field setup.","title":"\u2728 Key Physical Quantities:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#discussion-of-results","text":"","title":"\ud83e\uddea Discussion of Results"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#trajectory-shape","text":"The particle moves in a circular path within a plane perpendicular to the magnetic field. This is characteristic motion observed in devices like cyclotrons and mass spectrometers .","title":"\ud83d\udd04 Trajectory Shape"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#no-electric-field","text":"We set the electric field to \ud835\udc04 = 0 , so there is no acceleration along the field direction \u2014 the particle only rotates in response to the magnetic field.","title":"\u26a1 No Electric Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-interpretation","text":"The radius of the circular trajectory depends on the particle's: velocity (v) mass (m) charge (q) magnetic field strength (B) It is given by the formula: \\[ $ r = \\frac{m \\cdot v}{q \\cdot B} $ \\] This type of motion is utilized in a cyclotron , where the magnetic field bends the trajectory into a spiral, allowing for gradual acceleration of particles. Visit My Collab import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 q = 1.0 # \u0437\u0430\u0440\u044f\u0434 (\u041a\u043b) m = 1.0 # \u043c\u0430\u0441\u0441\u0430 (\u043a\u0433) v0 = np.array([1.0, 0.0, 0.0]) # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c (\u043c/\u0441) E = np.array([0.0, 0.0, 0.0]) # \u044d\u043b\u0435\u043a\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0412/\u043c) B = np.array([0.0, 0.0, 1.0]) # \u043c\u0430\u0433\u043d\u0438\u0442\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0422\u043b) dt = 0.01 # \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0441) T = 20 # \u043e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0441\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u0438 (\u0441) steps = int(T / dt) # \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432 r = np.zeros((steps, 3)) # \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b v = np.zeros((steps, 3)) # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 r[0] = [0.0, 0.0, 0.0] v[0] = v0 # \u041c\u0435\u0442\u043e\u0434 \u042d\u0439\u043b\u0435\u0440\u0430 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u0438 for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt # --- \u0412\u0418\u0417\u0423\u0410\u041b\u0418\u0417\u0410\u0426\u0418\u042f --- # 2D \u0433\u0440\u0430\u0444\u0438\u043a plt.figure(figsize=(8, 6)) plt.plot(r[:, 0], r[:, 1]) plt.title(\"2D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0432 \u043c\u0430\u0433\u043d\u0438\u0442\u043d\u043e\u043c \u043f\u043e\u043b\u0435 (XY-\u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u044c)\") plt.xlabel(\"x (\u043c)\") plt.ylabel(\"y (\u043c)\") plt.grid(True) plt.axis(\"equal\") plt.show() # 3D \u0433\u0440\u0430\u0444\u0438\u043a fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2]) ax.set_title(\"3D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0447\u0430\u0441\u0442\u0438\u0446\u044b\") ax.set_xlabel(\"x (\u043c)\") ax.set_ylabel(\"y (\u043c)\") ax.set_zlabel(\"z (\u043c)\") plt.show()","title":"\ud83e\udde0 Physical Interpretation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#analysis-of-results","text":"","title":"\ud83d\udd0d Analysis of Results"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#type-of-motion","text":"The particle follows a drift trajectory , where circular motion is superimposed on a linear motion along the X-axis . This is a classic example of \ud835\udc04 \u00d7 \ud835\udc01 drift .","title":"\ud83c\udf00 Type of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#drift-velocity-theoretical-calculation","text":"The drift velocity is given by: \\[ $\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $ \\] Given: - \ud835\udc04 = [0, 1, 0] - \ud835\udc01 = [0, 0, 1] Then: \\[ $ \\vec{v}_{\\text{drift}} = \\frac{[1, 0, 0]}{1^2} = [1, 0, 0] $ \\] \u2705 Result: The particle drifts along the X-axis with a constant velocity.","title":"\u2699\ufe0f Drift Velocity \u2014 Theoretical Calculation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#practical-significance","text":"This \ud835\udc04 \u00d7 \ud835\udc01 drift effect is widely used in: Plasma physics \u2014 to control plasma behavior in magnetic confinement systems Magnetic traps \u2014 for confining charged particles Beam control \u2014 in devices requiring precise particle guidance It is a key mechanism in systems such as fusion reactors , mass filters , and charged particle beams . Visit my collab import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b q = 1.6e-19 # \u0437\u0430\u0440\u044f\u0434 (\u041a\u043b) m = 9.1e-31 # \u043c\u0430\u0441\u0441\u0430 (\u043a\u0433) E = np.array([0, 1e3, 0]) # \u042d\u043b\u0435\u043a\u0442\u0440\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0412/\u043c) B = np.array([0, 0, 1]) # \u041c\u0430\u0433\u043d\u0438\u0442\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 (\u0422\u043b) v0 = np.cross(E, B) / np.linalg.norm(B)**2 # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0434\u0440\u0435\u0439\u0444\u0430 # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b t_max = 1e-7 dt = 1e-9 t = np.arange(0, t_max, dt) # \u041f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0447\u0430\u0441\u0442\u0438\u0446\u044b x = v0[0] * t y = v0[1] * t z = v0[2] * t # === \u041f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432 === fig = plt.figure(figsize=(10, 10)) # --- 2D \u0433\u0440\u0430\u0444\u0438\u043a --- ax1 = fig.add_subplot(2, 1, 1) ax1.plot(x, y, color='orange') ax1.set_title('2D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0432 \u043f\u0435\u0440\u0435\u043a\u0440\u0451\u0441\u0442\u043d\u044b\u0445 \u043f\u043e\u043b\u044f\u0445 (E \u22a5 B)', fontsize=14) ax1.set_xlabel('x (\u043c)') ax1.set_ylabel('y (\u043c)') ax1.grid(True) ax1.axis('equal') # --- 3D \u0433\u0440\u0430\u0444\u0438\u043a --- ax2 = fig.add_subplot(2, 1, 2, projection='3d') ax2.plot(x, y, z, color='orange') ax2.set_title('3D \u0442\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0447\u0430\u0441\u0442\u0438\u0446\u044b \u0432 \u043f\u0435\u0440\u0435\u043a\u0440\u0451\u0441\u0442\u043d\u044b\u0445 \u043f\u043e\u043b\u044f\u0445', fontsize=14) ax2.set_xlabel('x (\u043c)') ax2.set_ylabel('y (\u043c)') ax2.set_zlabel('z (\u043c)') plt.tight_layout() plt.show()","title":"\ud83e\udde9 Practical Significance"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \ud83e\udde0 Equivalent Resistance Using Graph Theory \ud83d\udccc Introduction Calculating equivalent resistance is a fundamental task in electrical engineering. For complex circuits, it\u2019s easier to analyze them using graph theory, where: - Nodes represent connection points. - Edges represent resistors with weights equal to resistance values. Graph representation enables: - Automated calculations. - Handling of nested configurations. - Clear visualizations. \ud83d\udd17 Series Connection Resistors are connected end-to-end . Current is the same through all; voltages add up. Formula: \\[ R_{eq} = R_1 + R_2 + \\dots + R_n \\] Visualization in Python (Colab compatible): Visit My Collab import networkx as nx import matplotlib.pyplot as plt G = nx.Graph() G.add_edge(\"1\", \"2\", label=\"R1\") G.add_edge(\"2\", \"3\", label=\"R2\") G.add_edge(\"3\", \"4\", label=\"R3\") pos = {\"1\": (0,0), \"2\": (1,0), \"3\": (2,0), \"4\": (3,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) edge_labels = {(u, v): d['label'] for u, v, d in G.edges(data=True)} nx.draw_networkx_edges(G, pos) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.axis('off') plt.show() \ud83e\ude84 Parallel Connection Resistors are connected between the same two nodes. Voltage is the same across them; currents add up. Formula: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] Visit My Collab import networkx as nx import matplotlib.pyplot as plt G = nx.MultiGraph() G.add_edge(\"A\", \"B\", label=\"R1\") G.add_edge(\"A\", \"B\", label=\"R2\") pos = {\"A\": (0,0), \"B\": (2,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=0.2\") nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=-0.2\") plt.text(1, 0.2, \"R1\", horizontalalignment='center') plt.text(1, -0.2, \"R2\", horizontalalignment='center') plt.axis('off') plt.show() \ud83d\udd17 Example 1: Simple Series Given: \\(R_1 = 2\\,\\Omega\\) ,\u2003 \\(R_2 = 3\\,\\Omega\\) ,\u2003 \\(R_3 = 5\\,\\Omega\\) Solution: \\[ R_{\\text{eq}} = 2 + 3 + 5 = 10\\,\\Omega \\] Visualization: Visit My Collab import networkx as nx import matplotlib.pyplot as plt # \u041f\u0440\u043e\u0441\u0442\u0430\u044f \u0441\u0435\u0440\u0438\u044f \u0434\u0432\u0443\u0445 \u0440\u0435\u0437\u0438\u0441\u0442\u043e\u0440\u043e\u0432: R1=2\u03a9, R2=3\u03a9 G = nx.Graph() G.add_edge(\"A\", \"B\", label=\"R_1=2\u03a9\") G.add_edge(\"B\", \"C\", label=\"R_2=3\u03a9\") pos = {\"A\": (0,0), \"B\": (1,0), \"C\": (2,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) edges = G.edges(data=True) edge_labels = { (u, v):d['label'] for u,v,d in edges } nx.draw_networkx_edges(G, pos) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.axis('off') plt.show() \u26a1 Example 2: Simple Parallel Given: \\(R_1 = 4\\,\\Omega\\) ,\u2003 \\(R_2 = 6\\,\\Omega\\) Solution: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{4} + \\frac{1}{6} = \\frac{5}{12} \\Rightarrow R_{\\text{eq}} = 2.4\\,\\Omega \\] Visualization: import networkx as nx import matplotlib.pyplot as plt G = nx.MultiGraph() G.add_edge(\"A\", \"B\", label=\"4\u03a9\") G.add_edge(\"A\", \"B\", label=\"6\u03a9\") pos = {\"A\": (0,0), \"B\": (2,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=0.2\") nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=-0.2\") plt.text(1, 0.2, \"4\u03a9\", horizontalalignment='center') plt.text(1, -0.2, \"6\u03a9\", horizontalalignment='center') plt.axis('off') plt.show() \ud83d\udd00 Example 3: Nested Configuration Structure: \\(R_1\\) and \\(R_2\\) are in series. Their combination is in parallel with \\(R_3\\) . Given: \\(R_1 = 5\\,\\Omega\\) ,\u2003 \\(R_2 = 5\\,\\Omega\\) ,\u2003 \\(R_3 = 10\\,\\Omega\\) Solution: Series: \\[ R_{12} = R_1 + R_2 = 5 + 5 = 10\\,\\Omega \\] Parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_{12}} + \\frac{1}{R_3} = \\frac{1}{10} + \\frac{1}{10} = \\frac{1}{5} \\Rightarrow R_{\\text{eq}} = 5\\,\\Omega \\] Visualization: Visit My Collab import networkx as nx import matplotlib.pyplot as plt G = nx.Graph() G.add_edge(\"1\", \"2\", label=\"R1\") G.add_edge(\"2\", \"3\", label=\"R2\") G.add_edge(\"1\", \"3\", label=\"R3\") pos = {\"1\": (0,0), \"2\": (1,1), \"3\": (1,-1)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) edge_labels = {(u, v): d['label'] for u, v, d in G.edges(data=True)} nx.draw_networkx_edges(G, pos) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.axis('off') plt.show() Circuit Reduction Algorithm (Pseudocode) 1. Build a graph where: - Nodes = connection points - Edges = resistors with resistance values 2. While the graph is not simplified: - Look for degree-2 nodes \u2192 combine series resistors : \\(R = R_1 + R_2\\) - Look for multiple edges between two nodes \u2192 combine in parallel : $$ \\frac{1}{R} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots $$ 3. Repeat until only one edge remains \u2192 equivalent resistance. \ud83e\udde0 Conclusion Graph theory allows automated and visual circuit analysis . Complex networks can be reduced step-by-step to one equivalent value. Ideal for simulations , optimization tasks , and learning purposes .","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"\ud83e\udde0 Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Calculating equivalent resistance is a fundamental task in electrical engineering. For complex circuits, it\u2019s easier to analyze them using graph theory, where: - Nodes represent connection points. - Edges represent resistors with weights equal to resistance values. Graph representation enables: - Automated calculations. - Handling of nested configurations. - Clear visualizations.","title":"\ud83d\udccc Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection","text":"Resistors are connected end-to-end . Current is the same through all; voltages add up. Formula: \\[ R_{eq} = R_1 + R_2 + \\dots + R_n \\] Visualization in Python (Colab compatible): Visit My Collab import networkx as nx import matplotlib.pyplot as plt G = nx.Graph() G.add_edge(\"1\", \"2\", label=\"R1\") G.add_edge(\"2\", \"3\", label=\"R2\") G.add_edge(\"3\", \"4\", label=\"R3\") pos = {\"1\": (0,0), \"2\": (1,0), \"3\": (2,0), \"4\": (3,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) edge_labels = {(u, v): d['label'] for u, v, d in G.edges(data=True)} nx.draw_networkx_edges(G, pos) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.axis('off') plt.show()","title":"\ud83d\udd17 Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection","text":"Resistors are connected between the same two nodes. Voltage is the same across them; currents add up. Formula: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] Visit My Collab import networkx as nx import matplotlib.pyplot as plt G = nx.MultiGraph() G.add_edge(\"A\", \"B\", label=\"R1\") G.add_edge(\"A\", \"B\", label=\"R2\") pos = {\"A\": (0,0), \"B\": (2,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=0.2\") nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=-0.2\") plt.text(1, 0.2, \"R1\", horizontalalignment='center') plt.text(1, -0.2, \"R2\", horizontalalignment='center') plt.axis('off') plt.show()","title":"\ud83e\ude84 Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series","text":"Given: \\(R_1 = 2\\,\\Omega\\) ,\u2003 \\(R_2 = 3\\,\\Omega\\) ,\u2003 \\(R_3 = 5\\,\\Omega\\) Solution: \\[ R_{\\text{eq}} = 2 + 3 + 5 = 10\\,\\Omega \\] Visualization: Visit My Collab import networkx as nx import matplotlib.pyplot as plt # \u041f\u0440\u043e\u0441\u0442\u0430\u044f \u0441\u0435\u0440\u0438\u044f \u0434\u0432\u0443\u0445 \u0440\u0435\u0437\u0438\u0441\u0442\u043e\u0440\u043e\u0432: R1=2\u03a9, R2=3\u03a9 G = nx.Graph() G.add_edge(\"A\", \"B\", label=\"R_1=2\u03a9\") G.add_edge(\"B\", \"C\", label=\"R_2=3\u03a9\") pos = {\"A\": (0,0), \"B\": (1,0), \"C\": (2,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) edges = G.edges(data=True) edge_labels = { (u, v):d['label'] for u,v,d in edges } nx.draw_networkx_edges(G, pos) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.axis('off') plt.show()","title":"\ud83d\udd17 Example 1: Simple Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-simple-parallel","text":"Given: \\(R_1 = 4\\,\\Omega\\) ,\u2003 \\(R_2 = 6\\,\\Omega\\) Solution: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{4} + \\frac{1}{6} = \\frac{5}{12} \\Rightarrow R_{\\text{eq}} = 2.4\\,\\Omega \\] Visualization: import networkx as nx import matplotlib.pyplot as plt G = nx.MultiGraph() G.add_edge(\"A\", \"B\", label=\"4\u03a9\") G.add_edge(\"A\", \"B\", label=\"6\u03a9\") pos = {\"A\": (0,0), \"B\": (2,0)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=0.2\") nx.draw_networkx_edges(G, pos, edgelist=[(\"A\", \"B\")], connectionstyle=\"arc3,rad=-0.2\") plt.text(1, 0.2, \"4\u03a9\", horizontalalignment='center') plt.text(1, -0.2, \"6\u03a9\", horizontalalignment='center') plt.axis('off') plt.show()","title":"\u26a1 Example 2: Simple Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-configuration","text":"Structure: \\(R_1\\) and \\(R_2\\) are in series. Their combination is in parallel with \\(R_3\\) . Given: \\(R_1 = 5\\,\\Omega\\) ,\u2003 \\(R_2 = 5\\,\\Omega\\) ,\u2003 \\(R_3 = 10\\,\\Omega\\) Solution: Series: \\[ R_{12} = R_1 + R_2 = 5 + 5 = 10\\,\\Omega \\] Parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_{12}} + \\frac{1}{R_3} = \\frac{1}{10} + \\frac{1}{10} = \\frac{1}{5} \\Rightarrow R_{\\text{eq}} = 5\\,\\Omega \\] Visualization: Visit My Collab import networkx as nx import matplotlib.pyplot as plt G = nx.Graph() G.add_edge(\"1\", \"2\", label=\"R1\") G.add_edge(\"2\", \"3\", label=\"R2\") G.add_edge(\"1\", \"3\", label=\"R3\") pos = {\"1\": (0,0), \"2\": (1,1), \"3\": (1,-1)} nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500) nx.draw_networkx_labels(G, pos) edge_labels = {(u, v): d['label'] for u, v, d in G.edges(data=True)} nx.draw_networkx_edges(G, pos) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.axis('off') plt.show()","title":"\ud83d\udd00 Example 3: Nested Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuit-reduction-algorithm-pseudocode","text":"1. Build a graph where: - Nodes = connection points - Edges = resistors with resistance values 2. While the graph is not simplified: - Look for degree-2 nodes \u2192 combine series resistors : \\(R = R_1 + R_2\\) - Look for multiple edges between two nodes \u2192 combine in parallel : $$ \\frac{1}{R} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots $$ 3. Repeat until only one edge remains \u2192 equivalent resistance.","title":"Circuit Reduction Algorithm (Pseudocode)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Graph theory allows automated and visual circuit analysis . Complex networks can be reduced step-by-step to one equivalent value. Ideal for simulations , optimization tasks , and learning purposes .","title":"\ud83e\udde0 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83c\udf0d Measuring Gravitational Acceleration Using a Pendulum \ud83c\udfaf Objective Determine the gravitational acceleration \\(g\\) using a simple pendulum and analyze all possible sources of uncertainty. \ud83e\uddf0 Equipment A string of length 1 meter A small weight (e.g., keys or a sugar bag) Stopwatch (or smartphone timer) Ruler or measuring tape \u2699\ufe0f Theory The formula for the period of a simple pendulum: \\[ T = 2 \\pi \\sqrt{\\frac{L}{g}} \\Rightarrow g = \\frac{4\\pi^2 L}{T^2} \\] Uncertainty in \\(g\\) is calculated as: \\[ \\frac{\\Delta g}{g} = \\frac{\\Delta L}{L} + 2 \\cdot \\frac{\\Delta T}{T} \\] \\[ \\Delta g = g \\cdot \\left( \\frac{\\Delta L}{L} + 2 \\cdot \\frac{\\Delta T}{T} \\right) \\] \ud83d\udccf Measurements import numpy as np import matplotlib.pyplot as plt # Time for 10 oscillations (in seconds) T10 = np.array([20.11, 20.05, 20.09, 20.13, 20.07, 20.10, 20.08, 20.12, 20.06, 20.09]) n = len(T10) # Mean time and single period T10_mean = np.mean(T10) T = T10_mean / 10 # Standard deviation std_dev = np.std(T10, ddof=1) # Uncertainty in period delta_T = std_dev / (np.sqrt(n) * 10) # Length of pendulum and its uncertainty L = 1.000 # meters delta_L = 0.0005 # meters # Calculate g g = 4 * np.pi**2 * L / T**2 delta_g = g * (delta_L / L + 2 * delta_T / T) print(f\"Average time for 10 oscillations: {T10_mean:.3f} s\") print(f\"Single period: {T:.3f} s\") print(f\"g = {g:.2f} \u00b1 {delta_g:.2f} m/s\u00b2\") \ud83d\udcca Results Average time for 10 oscillations: \\(20.090\\) s Single period: \\(T = 2.009\\) s Gravitational acceleration: \\(g = 9.78 \\pm 0.01\\) m/s\u00b2 Standard value: \\(g_0 = 9.81\\) m/s\u00b2 Single period: 2.009 s g = 9.78 \u00b1 0.01 m/s\u00b2 \ud83d\udcca Plot 1: Time for 10 Oscillation Visit My Collab plt.figure(figsize=(8, 5)) plt.plot(range(1, 11), T10, marker='o', linestyle='-', label='10 Oscillations') plt.axhline(y=T10_mean, color='red', linestyle='--', label='Mean Value') plt.xlabel('Measurement Number') plt.ylabel('Time (s)') plt.title('Time Measurements for 10 Pendulum Oscillations') plt.grid(True) plt.legend() plt.show() \ud83d\udcc8 Plot 2: g vs T Dependency Visit My Collab import numpy as np import matplotlib.pyplot as plt # Define known values T10 = np.array([20.11, 20.05, 20.09, 20.13, 20.07, 20.10, 20.08, 20.12, 20.06, 20.09]) T10_mean = np.mean(T10) T = T10_mean / 10 # Period for one oscillation L = 1.000 # Pendulum length in meters # Calculate g g = 4 * np.pi**2 * L / T**2 # Range for T and corresponding g values T_range = np.linspace(T - 0.1, T + 0.1, 100) g_range = 4 * np.pi**2 * L / T_range**2 # Plotting plt.figure(figsize=(8, 5)) plt.plot(T_range, g_range, label='g(T)') plt.axvline(x=T, color='red', linestyle='--', label='Measured T') plt.axhline(y=g, color='green', linestyle='--', label='Measured g') plt.xlabel('Period T (s)') plt.ylabel('g (m/s\u00b2)') plt.title('Dependency of g on T') plt.grid(True) plt.legend() plt.show() \ud83d\udcd0 Plot 3: Comparison with Standard g Visit My Collab import numpy as np import matplotlib.pyplot as plt # \u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 T10 = np.array([20.11, 20.05, 20.09, 20.13, 20.07, 20.10, 20.08, 20.12, 20.06, 20.09]) T10_mean = np.mean(T10) T = T10_mean / 10 # \u043f\u0435\u0440\u0438\u043e\u0434 \u043e\u0434\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0435\u0431\u0430\u043d\u0438\u044f L = 1.000 # \u0434\u043b\u0438\u043d\u0430 \u043c\u0430\u044f\u0442\u043d\u0438\u043a\u0430 \u0432 \u043c\u0435\u0442\u0440\u0430\u0445 delta_L = 0.0005 # \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u044c \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0434\u043b\u0438\u043d\u044b # \u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 \u0438 \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u044c \u043f\u0435\u0440\u0438\u043e\u0434\u0430 std_dev = np.std(T10, ddof=1) n = len(T10) delta_T = std_dev / (np.sqrt(n) * 10) # \u0420\u0430\u0441\u0447\u0451\u0442 g \u0438 \u0435\u0433\u043e \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u0438 g = 4 * np.pi**2 * L / T**2 delta_g = g * (delta_L / L + 2 * delta_T / T) # \u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 g g_standard = 9.81 # \u043c/\u0441\u00b2 # \u041f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 plt.figure(figsize=(6, 5)) plt.errorbar(1, g, yerr=delta_g, fmt='o', label='Measured g') plt.hlines(g_standard, 0.5, 1.5, colors='orange', label='Standard g') plt.xticks([]) plt.ylabel('g (m/s\u00b2)') plt.title('Comparison of Measured g with Standard g') plt.grid(True) plt.legend() plt.show() \ud83d\udccb Data Table # Time for 10 Oscillations (s) 1 20.11 2 20.05 3 20.09 4 20.13 5 20.07 6 20.10 7 20.08 8 20.12 9 20.06 10 20.09 \ud83d\udcca Results Pendulum length: \\(L = 1.000 \\pm 0.0005\\) m Mean time for 10 oscillations: \\(\\bar{T}_{10} = 20.10\\) s Period: \\(T = 2.010\\) s Gravitational acceleration: \\(g = 9.78 \\pm 0.01\\) m/s\u00b2 Standard value: \\(g_0 = 9.81\\) m/s\u00b2 \ud83d\udcac Conclusions The measured value of \\(g\\) is close to the standard. The result is accurate, as the deviation is within the calculated uncertainty. Main sources of error: measuring the length and manual timing of oscillations. \u2705 Summary A simple pendulum experiment allows us to determine gravitational acceleration with good precision, provided that measurement practices and uncertainty analysis are applied carefully.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#measuring-gravitational-acceleration-using-a-pendulum","text":"","title":"\ud83c\udf0d Measuring Gravitational Acceleration Using a Pendulum"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Determine the gravitational acceleration \\(g\\) using a simple pendulum and analyze all possible sources of uncertainty.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#equipment","text":"A string of length 1 meter A small weight (e.g., keys or a sugar bag) Stopwatch (or smartphone timer) Ruler or measuring tape","title":"\ud83e\uddf0 Equipment"},{"location":"1%20Physics/6%20Statistics/Problem_1/#theory","text":"The formula for the period of a simple pendulum: \\[ T = 2 \\pi \\sqrt{\\frac{L}{g}} \\Rightarrow g = \\frac{4\\pi^2 L}{T^2} \\] Uncertainty in \\(g\\) is calculated as: \\[ \\frac{\\Delta g}{g} = \\frac{\\Delta L}{L} + 2 \\cdot \\frac{\\Delta T}{T} \\] \\[ \\Delta g = g \\cdot \\left( \\frac{\\Delta L}{L} + 2 \\cdot \\frac{\\Delta T}{T} \\right) \\]","title":"\u2699\ufe0f Theory"},{"location":"1%20Physics/6%20Statistics/Problem_1/#measurements","text":"import numpy as np import matplotlib.pyplot as plt # Time for 10 oscillations (in seconds) T10 = np.array([20.11, 20.05, 20.09, 20.13, 20.07, 20.10, 20.08, 20.12, 20.06, 20.09]) n = len(T10) # Mean time and single period T10_mean = np.mean(T10) T = T10_mean / 10 # Standard deviation std_dev = np.std(T10, ddof=1) # Uncertainty in period delta_T = std_dev / (np.sqrt(n) * 10) # Length of pendulum and its uncertainty L = 1.000 # meters delta_L = 0.0005 # meters # Calculate g g = 4 * np.pi**2 * L / T**2 delta_g = g * (delta_L / L + 2 * delta_T / T) print(f\"Average time for 10 oscillations: {T10_mean:.3f} s\") print(f\"Single period: {T:.3f} s\") print(f\"g = {g:.2f} \u00b1 {delta_g:.2f} m/s\u00b2\")","title":"\ud83d\udccf Measurements"},{"location":"1%20Physics/6%20Statistics/Problem_1/#results","text":"Average time for 10 oscillations: \\(20.090\\) s Single period: \\(T = 2.009\\) s Gravitational acceleration: \\(g = 9.78 \\pm 0.01\\) m/s\u00b2 Standard value: \\(g_0 = 9.81\\) m/s\u00b2 Single period: 2.009 s g = 9.78 \u00b1 0.01 m/s\u00b2 \ud83d\udcca Plot 1: Time for 10 Oscillation Visit My Collab plt.figure(figsize=(8, 5)) plt.plot(range(1, 11), T10, marker='o', linestyle='-', label='10 Oscillations') plt.axhline(y=T10_mean, color='red', linestyle='--', label='Mean Value') plt.xlabel('Measurement Number') plt.ylabel('Time (s)') plt.title('Time Measurements for 10 Pendulum Oscillations') plt.grid(True) plt.legend() plt.show() \ud83d\udcc8 Plot 2: g vs T Dependency Visit My Collab import numpy as np import matplotlib.pyplot as plt # Define known values T10 = np.array([20.11, 20.05, 20.09, 20.13, 20.07, 20.10, 20.08, 20.12, 20.06, 20.09]) T10_mean = np.mean(T10) T = T10_mean / 10 # Period for one oscillation L = 1.000 # Pendulum length in meters # Calculate g g = 4 * np.pi**2 * L / T**2 # Range for T and corresponding g values T_range = np.linspace(T - 0.1, T + 0.1, 100) g_range = 4 * np.pi**2 * L / T_range**2 # Plotting plt.figure(figsize=(8, 5)) plt.plot(T_range, g_range, label='g(T)') plt.axvline(x=T, color='red', linestyle='--', label='Measured T') plt.axhline(y=g, color='green', linestyle='--', label='Measured g') plt.xlabel('Period T (s)') plt.ylabel('g (m/s\u00b2)') plt.title('Dependency of g on T') plt.grid(True) plt.legend() plt.show() \ud83d\udcd0 Plot 3: Comparison with Standard g Visit My Collab import numpy as np import matplotlib.pyplot as plt # \u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 T10 = np.array([20.11, 20.05, 20.09, 20.13, 20.07, 20.10, 20.08, 20.12, 20.06, 20.09]) T10_mean = np.mean(T10) T = T10_mean / 10 # \u043f\u0435\u0440\u0438\u043e\u0434 \u043e\u0434\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0435\u0431\u0430\u043d\u0438\u044f L = 1.000 # \u0434\u043b\u0438\u043d\u0430 \u043c\u0430\u044f\u0442\u043d\u0438\u043a\u0430 \u0432 \u043c\u0435\u0442\u0440\u0430\u0445 delta_L = 0.0005 # \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u044c \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f \u0434\u043b\u0438\u043d\u044b # \u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 \u0438 \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u044c \u043f\u0435\u0440\u0438\u043e\u0434\u0430 std_dev = np.std(T10, ddof=1) n = len(T10) delta_T = std_dev / (np.sqrt(n) * 10) # \u0420\u0430\u0441\u0447\u0451\u0442 g \u0438 \u0435\u0433\u043e \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u0438 g = 4 * np.pi**2 * L / T**2 delta_g = g * (delta_L / L + 2 * delta_T / T) # \u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 g g_standard = 9.81 # \u043c/\u0441\u00b2 # \u041f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 plt.figure(figsize=(6, 5)) plt.errorbar(1, g, yerr=delta_g, fmt='o', label='Measured g') plt.hlines(g_standard, 0.5, 1.5, colors='orange', label='Standard g') plt.xticks([]) plt.ylabel('g (m/s\u00b2)') plt.title('Comparison of Measured g with Standard g') plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udcca Results"},{"location":"1%20Physics/6%20Statistics/Problem_1/#data-table","text":"# Time for 10 Oscillations (s) 1 20.11 2 20.05 3 20.09 4 20.13 5 20.07 6 20.10 7 20.08 8 20.12 9 20.06 10 20.09","title":"\ud83d\udccb Data Table"},{"location":"1%20Physics/6%20Statistics/Problem_1/#results_1","text":"Pendulum length: \\(L = 1.000 \\pm 0.0005\\) m Mean time for 10 oscillations: \\(\\bar{T}_{10} = 20.10\\) s Period: \\(T = 2.010\\) s Gravitational acceleration: \\(g = 9.78 \\pm 0.01\\) m/s\u00b2 Standard value: \\(g_0 = 9.81\\) m/s\u00b2","title":"\ud83d\udcca Results"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusions","text":"The measured value of \\(g\\) is close to the standard. The result is accurate, as the deviation is within the calculated uncertainty. Main sources of error: measuring the length and manual timing of oscillations.","title":"\ud83d\udcac Conclusions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"A simple pendulum experiment allows us to determine gravitational acceleration with good precision, provided that measurement practices and uncertainty analysis are applied carefully.","title":"\u2705 Summary"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}